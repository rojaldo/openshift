<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>Temario: Curso de Docker</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Temario: Curso de Docker</h1>
<div id="toc" class="toc2">
<div id="toctitle">Contenidos</div>
<ul class="sectlevel1">
<li><a href="#_introducción_a_docker">Introducción a Docker</a>
<ul class="sectlevel2">
<li><a href="#_conceptos_básicos_de_contenedores_y_virtualización">Conceptos básicos de contenedores y virtualización</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_la_virtualización">¿Qué es la virtualización?</a></li>
<li><a href="#_qué_es_un_contenedor">¿Qué es un contenedor?</a></li>
<li><a href="#_cómo_funcionan_los_contenedores">¿Cómo funcionan los contenedores?</a></li>
<li><a href="#_ejemplo_práctico_diferencias_entre_vm_y_contenedor">Ejemplo práctico: diferencias entre VM y contenedor</a></li>
<li><a href="#_resumen_gráfico">Resumen gráfico</a></li>
</ul>
</li>
<li><a href="#_historia_y_evolución_de_docker">Historia y evolución de Docker</a>
<ul class="sectlevel3">
<li><a href="#_orígenes_de_docker">Orígenes de Docker</a></li>
<li><a href="#_línea_de_tiempo_de_hitos_importantes">Línea de tiempo de hitos importantes</a></li>
<li><a href="#_evolución_tecnológica">Evolución tecnológica</a></li>
<li><a href="#_impacto_en_la_industria">Impacto en la industria</a></li>
<li><a href="#_ejemplo_primer_comando_histórico_de_docker">Ejemplo: primer comando histórico de Docker</a></li>
<li><a href="#_resumen_gráfico_de_la_evolución">Resumen gráfico de la evolución</a></li>
</ul>
</li>
<li><a href="#_arquitectura_de_docker">Arquitectura de Docker</a>
<ul class="sectlevel3">
<li><a href="#_componentes_principales_de_docker">Componentes principales de Docker</a></li>
<li><a href="#_diagrama_de_arquitectura">Diagrama de arquitectura</a></li>
<li><a href="#_flujo_de_trabajo_típico">Flujo de trabajo típico</a></li>
<li><a href="#_ejemplo_práctico_ciclo_de_vida_de_un_contenedor">Ejemplo práctico: ciclo de vida de un contenedor</a></li>
<li><a href="#_resumen_de_la_arquitectura">Resumen de la arquitectura</a></li>
<li><a href="#_ventajas_de_la_arquitectura_de_docker">Ventajas de la arquitectura de Docker</a></li>
</ul>
</li>
<li><a href="#_instalación_de_docker_y_alternativas_a_docker">Instalación de Docker y alternativas a Docker</a>
<ul class="sectlevel3">
<li><a href="#_instalación_de_docker_en_diferentes_sistemas_operativos">Instalación de Docker en diferentes sistemas operativos</a></li>
<li><a href="#_alternativas_a_docker">Alternativas a Docker</a></li>
<li><a href="#_consideraciones_de_seguridad_y_permisos">Consideraciones de seguridad y permisos</a></li>
<li><a href="#_resumen">Resumen</a></li>
</ul>
</li>
<li><a href="#_primeros_pasos_comandos_básicos">Primeros pasos: comandos básicos</a>
<ul class="sectlevel3">
<li><a href="#_descargar_y_ejecutar_tu_primer_contenedor">Descargar y ejecutar tu primer contenedor</a></li>
<li><a href="#_listar_imágenes_y_contenedores">Listar imágenes y contenedores</a></li>
<li><a href="#_descargar_imágenes_desde_docker_hub">Descargar imágenes desde Docker Hub</a></li>
<li><a href="#_crear_y_ejecutar_un_contenedor">Crear y ejecutar un contenedor</a></li>
<li><a href="#_acceder_a_un_contenedor_en_ejecución">Acceder a un contenedor en ejecución</a></li>
<li><a href="#_detener_y_eliminar_contenedores">Detener y eliminar contenedores</a></li>
<li><a href="#_eliminar_imágenes">Eliminar imágenes</a></li>
<li><a href="#_ver_logs_de_un_contenedor">Ver logs de un contenedor</a></li>
<li><a href="#_resumen_de_comandos_básicos">Resumen de comandos básicos</a></li>
<li><a href="#_ejemplo_práctico_ciclo_de_vida_de_un_contenedor_2">Ejemplo práctico: ciclo de vida de un contenedor</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_imágenes_y_contenedores_docker">Imágenes y Contenedores Docker</a>
<ul class="sectlevel2">
<li><a href="#_entendiendo_las_imágenes_docker">Entendiendo las imágenes Docker</a>
<ul class="sectlevel3">
<li><a href="#_características_principales_de_las_imágenes_docker">Características principales de las imágenes Docker</a></li>
<li><a href="#_dockerfile">Dockerfile</a></li>
<li><a href="#_estructura_de_una_imagen_docker">Estructura de una imagen Docker</a></li>
<li><a href="#_ejemplo_listar_imágenes_disponibles">Ejemplo: listar imágenes disponibles</a></li>
<li><a href="#_descargar_una_imagen_desde_docker_hub">Descargar una imagen desde Docker Hub</a></li>
<li><a href="#_inspeccionar_una_imagen">Inspeccionar una imagen</a></li>
<li><a href="#_ejemplo_de_uso_de_una_imagen">Ejemplo de uso de una imagen</a></li>
<li><a href="#_buenas_prácticas_al_trabajar_con_imágenes">Buenas prácticas al trabajar con imágenes</a></li>
</ul>
</li>
<li><a href="#_gestión_de_contenedores">Gestión de contenedores</a>
<ul class="sectlevel3">
<li><a href="#_crear_y_ejecutar_contenedores">Crear y ejecutar contenedores</a></li>
<li><a href="#_listar_contenedores">Listar contenedores</a></li>
<li><a href="#_detener_iniciar_y_reiniciar_contenedores">Detener, iniciar y reiniciar contenedores</a></li>
<li><a href="#_eliminar_contenedores">Eliminar contenedores</a></li>
<li><a href="#_inspeccionar_contenedores">Inspeccionar contenedores</a></li>
<li><a href="#_ver_el_uso_de_recursos_de_los_contenedores">Ver el uso de recursos de los contenedores</a></li>
<li><a href="#_copiar_archivos_entre_el_host_y_el_contenedor">Copiar archivos entre el host y el contenedor</a></li>
<li><a href="#_ejemplo_práctico_gestión_completa_de_un_contenedor">Ejemplo práctico: gestión completa de un contenedor</a></li>
<li><a href="#_buenas_prácticas_en_la_gestión_de_contenedores">Buenas prácticas en la gestión de contenedores</a></li>
</ul>
</li>
<li><a href="#_ciclo_de_vida_de_un_contenedor">Ciclo de vida de un contenedor</a>
<ul class="sectlevel3">
<li><a href="#_etapas_del_ciclo_de_vida">Etapas del ciclo de vida</a></li>
<li><a href="#_diagrama_del_ciclo_de_vida">Diagrama del ciclo de vida</a></li>
<li><a href="#_ejemplo_práctico">Ejemplo práctico</a></li>
<li><a href="#_estados_de_un_contenedor">Estados de un contenedor</a></li>
</ul>
</li>
<li><a href="#_comandos_esenciales_run_ps_pull_exec_logs_etc">Comandos esenciales (run, ps, pull, exec, logs, etc.)</a>
<ul class="sectlevel3">
<li><a href="#_docker_run">docker run</a></li>
<li><a href="#_docker_ps">docker ps</a></li>
<li><a href="#_docker_pull">docker pull</a></li>
<li><a href="#_docker_exec">docker exec</a></li>
<li><a href="#_docker_logs">docker logs</a></li>
<li><a href="#_otros_comandos_esenciales">Otros comandos esenciales</a></li>
<li><a href="#_resumen_práctico">Resumen práctico</a></li>
<li><a href="#_buenas_prácticas">Buenas prácticas</a></li>
<li><a href="#_ejemplo_de_ciclo_completo">Ejemplo de ciclo completo</a></li>
</ul>
</li>
<li><a href="#_depuración_y_solución_de_problemas">Depuración y solución de problemas</a>
<ul class="sectlevel3">
<li><a href="#_inspección_de_contenedores_y_logs">Inspección de contenedores y logs</a></li>
<li><a href="#_acceso_interactivo_y_ejecución_de_comandos">Acceso interactivo y ejecución de comandos</a></li>
<li><a href="#_monitorización_de_recursos">Monitorización de recursos</a></li>
<li><a href="#_diagnóstico_de_redes_y_conectividad">Diagnóstico de redes y conectividad</a></li>
<li><a href="#_solución_de_problemas_comunes">Solución de problemas comunes</a></li>
<li><a href="#_herramientas_avanzadas_de_depuración">Herramientas avanzadas de depuración</a></li>
<li><a href="#_ejemplo_práctico_de_depuración">Ejemplo práctico de depuración</a></li>
<li><a href="#_buenas_prácticas_para_evitar_y_resolver_problemas">Buenas prácticas para evitar y resolver problemas</a></li>
<li><a href="#_recursos_adicionales">Recursos adicionales</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_creación_de_imágenes_docker">Creación de Imágenes Docker</a>
<ul class="sectlevel2">
<li><a href="#_introducción_a_dockerfile">Introducción a Dockerfile</a>
<ul class="sectlevel3">
<li><a href="#_por_qué_usar_dockerfile">¿Por qué usar Dockerfile?</a></li>
<li><a href="#_estructura_básica_de_un_dockerfile">Estructura básica de un Dockerfile</a></li>
<li><a href="#_ejemplo_sencillo_de_dockerfile">Ejemplo sencillo de Dockerfile</a></li>
<li><a href="#_proceso_de_construcción_de_una_imagen">Proceso de construcción de una imagen</a></li>
<li><a href="#_buenas_prácticas_iniciales">Buenas prácticas iniciales</a></li>
</ul>
</li>
<li><a href="#_instrucciones_básicas">Instrucciones básicas</a>
<ul class="sectlevel3">
<li><a href="#_from">FROM</a></li>
<li><a href="#_run">RUN</a></li>
<li><a href="#_copy">COPY</a></li>
<li><a href="#_add">ADD</a></li>
<li><a href="#_workdir">WORKDIR</a></li>
<li><a href="#_env">ENV</a></li>
<li><a href="#_expose">EXPOSE</a></li>
<li><a href="#_cmd">CMD</a></li>
<li><a href="#_entrypoint">ENTRYPOINT</a></li>
<li><a href="#_user">USER</a></li>
<li><a href="#_label">LABEL</a></li>
<li><a href="#_ejemplo_completo_de_dockerfile">Ejemplo completo de Dockerfile</a></li>
<li><a href="#_resumen_2">Resumen</a></li>
</ul>
</li>
<li><a href="#_buenas_prácticas_en_la_creación_de_imágenes">Buenas prácticas en la creación de imágenes</a>
<ul class="sectlevel3">
<li><a href="#_usa_imágenes_base_oficiales_y_ligeras">Usa imágenes base oficiales y ligeras</a></li>
<li><a href="#_minimiza_el_número_de_capas">Minimiza el número de capas</a></li>
<li><a href="#_elimina_archivos_temporales_y_cachés">Elimina archivos temporales y cachés</a></li>
<li><a href="#_usa_copy_en_lugar_de_add">Usa COPY en lugar de ADD</a></li>
<li><a href="#_define_variables_de_entorno_y_puertos_explícitamente">Define variables de entorno y puertos explícitamente</a></li>
<li><a href="#_no_incluyas_secretos_ni_archivos_sensibles">No incluyas secretos ni archivos sensibles</a></li>
<li><a href="#_usa_usuarios_no_privilegiados">Usa usuarios no privilegiados</a></li>
<li><a href="#_mantén_el_dockerfile_limpio_y_ordenado">Mantén el Dockerfile limpio y ordenado</a></li>
<li><a href="#_versiona_tus_imágenes">Versiona tus imágenes</a></li>
<li><a href="#_usa_archivos_dockerignore">Usa archivos .dockerignore</a></li>
<li><a href="#_11_actualiza_y_revisa_tus_imágenes_regularmente">11. Actualiza y revisa tus imágenes regularmente</a></li>
<li><a href="#_12_ejemplo_de_dockerfile_siguiendo_buenas_prácticas">12. Ejemplo de Dockerfile siguiendo buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_optimización_de_imágenes_tamaño_y_capas">Optimización de imágenes: tamaño y capas</a>
<ul class="sectlevel3">
<li><a href="#_usa_imágenes_base_minimalistas">Usa imágenes base minimalistas</a></li>
<li><a href="#_agrupa_comandos_en_una_sola_instrucción_run">Agrupa comandos en una sola instrucción RUN</a></li>
<li><a href="#_elimina_archivos_innecesarios_y_cachés">Elimina archivos innecesarios y cachés</a></li>
<li><a href="#_usa_archivos_dockerignore_2">Usa archivos .dockerignore</a></li>
<li><a href="#_copia_solo_lo_necesario">Copia solo lo necesario</a></li>
<li><a href="#_multi_stage_builds_construcción_multietapa">Multi-stage builds (construcción multietapa)</a></li>
<li><a href="#_elimina_herramientas_de_desarrollo_en_producción">Elimina herramientas de desarrollo en producción</a></li>
<li><a href="#_usa_imágenes_oficiales_y_mantenidas">Usa imágenes oficiales y mantenidas</a></li>
<li><a href="#_analiza_y_revisa_el_tamaño_de_tus_imágenes">Analiza y revisa el tamaño de tus imágenes</a></li>
<li><a href="#_ejemplo_de_dockerfile_optimizado">Ejemplo de Dockerfile optimizado</a></li>
<li><a href="#_resumen_de_recomendaciones">Resumen de recomendaciones</a></li>
</ul>
</li>
<li><a href="#_imágenes_multietapa">Imágenes multietapa</a>
<ul class="sectlevel3">
<li><a href="#_ventajas_de_las_imágenes_multietapa">Ventajas de las imágenes multietapa</a></li>
<li><a href="#_sintaxis_y_funcionamiento">Sintaxis y funcionamiento</a></li>
<li><a href="#_ejemplo_práctico_aplicación_go">Ejemplo práctico: aplicación Go</a></li>
<li><a href="#_multi_stage_para_eliminar_dependencias_de_desarrollo">Multi-stage para eliminar dependencias de desarrollo</a></li>
<li><a href="#_buenas_prácticas_con_imágenes_multietapa">Buenas prácticas con imágenes multietapa</a></li>
</ul>
</li>
<li><a href="#_publicación_de_imágenes_en_docker_hub">Publicación de imágenes en Docker Hub</a>
<ul class="sectlevel3">
<li><a href="#_crear_una_cuenta_en_docker_hub">Crear una cuenta en Docker Hub</a></li>
<li><a href="#_iniciar_sesión_desde_la_terminal">Iniciar sesión desde la terminal</a></li>
<li><a href="#_etiquetar_la_imagen_para_docker_hub">Etiquetar la imagen para Docker Hub</a></li>
<li><a href="#_subir_la_imagen_al_registro">Subir la imagen al registro</a></li>
<li><a href="#_verificar_la_publicación">Verificar la publicación</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_redes_en_docker">Redes en Docker</a>
<ul class="sectlevel2">
<li><a href="#_tipos_de_redes_en_docker">Tipos de redes en Docker</a>
<ul class="sectlevel3">
<li><a href="#_bridge_puente">bridge (puente)</a></li>
<li><a href="#_host">host</a></li>
<li><a href="#_none">none</a></li>
<li><a href="#_overlay">overlay</a></li>
<li><a href="#_macvlan">macvlan</a></li>
<li><a href="#_resumen_comparativo">Resumen comparativo</a></li>
</ul>
</li>
<li><a href="#_comunicación_entre_contenedores">Comunicación entre contenedores</a>
<ul class="sectlevel3">
<li><a href="#_comunicación_en_la_red_bridge_por_defecto">Comunicación en la red bridge (por defecto)</a></li>
<li><a href="#_comunicación_usando_nombres_de_contenedor">Comunicación usando nombres de contenedor</a></li>
<li><a href="#_comunicación_entre_redes_diferentes">Comunicación entre redes diferentes</a></li>
<li><a href="#_exposición_de_servicios_al_exterior">Exposición de servicios al exterior</a></li>
<li><a href="#_buenas_prácticas_2">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_exposición_y_mapeo_de_puertos">Exposición y mapeo de puertos</a>
<ul class="sectlevel3">
<li><a href="#_exponer_puertos_en_el_dockerfile">Exponer puertos en el Dockerfile</a></li>
<li><a href="#_mapeo_de_puertos_al_ejecutar_un_contenedor">Mapeo de puertos al ejecutar un contenedor</a></li>
<li><a href="#_mapeo_de_puertos_en_modo_aleatorio">Mapeo de puertos en modo aleatorio</a></li>
<li><a href="#_mapeo_de_puertos_en_interfaces_específicas">Mapeo de puertos en interfaces específicas</a></li>
<li><a href="#_ejemplo_práctico_2">Ejemplo práctico</a></li>
<li><a href="#_buenas_prácticas_3">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_dns_y_nombres_de_host">DNS y nombres de host</a>
<ul class="sectlevel3">
<li><a href="#_resolución_automática_de_nombres">Resolución automática de nombres</a></li>
<li><a href="#_alias_de_red">Alias de red</a></li>
<li><a href="#_personalización_del_hostname">Personalización del hostname</a></li>
<li><a href="#_modificación_del_archivo_etchosts">Modificación del archivo /etc/hosts</a></li>
<li><a href="#_descubrimiento_de_servicios_en_redes_overlay">Descubrimiento de servicios en redes overlay</a></li>
<li><a href="#_buenas_prácticas_4">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_creación_y_gestión_de_redes_personalizadas">Creación y gestión de redes personalizadas</a>
<ul class="sectlevel3">
<li><a href="#_por_qué_usar_redes_personalizadas">¿Por qué usar redes personalizadas?</a></li>
<li><a href="#_crear_una_red_personalizada">Crear una red personalizada</a></li>
<li><a href="#_conectar_contenedores_a_una_red_personalizada">Conectar contenedores a una red personalizada</a></li>
<li><a href="#_conectar_un_contenedor_existente_a_otra_red">Conectar un contenedor existente a otra red</a></li>
<li><a href="#_inspeccionar_y_gestionar_redes">Inspeccionar y gestionar redes</a></li>
<li><a href="#_eliminar_una_red_personalizada">Eliminar una red personalizada</a></li>
<li><a href="#_ejemplo_práctico_completo">Ejemplo práctico completo</a></li>
<li><a href="#_redes_avanzadas_overlay_y_macvlan">Redes avanzadas: overlay y macvlan</a></li>
<li><a href="#_buenas_prácticas_5">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_persistencia_de_datos">Persistencia de Datos</a>
<ul class="sectlevel2">
<li><a href="#_volúmenes_docker">Volúmenes Docker</a>
<ul class="sectlevel3">
<li><a href="#_por_qué_usar_volúmenes">¿Por qué usar volúmenes?</a></li>
<li><a href="#_crear_y_gestionar_volúmenes">Crear y gestionar volúmenes</a></li>
<li><a href="#_usar_volúmenes_en_contenedores">Usar volúmenes en contenedores</a></li>
<li><a href="#_compartir_volúmenes_entre_contenedores">Compartir volúmenes entre contenedores</a></li>
<li><a href="#_ubicación_de_los_volúmenes">Ubicación de los volúmenes</a></li>
<li><a href="#_ejemplo_práctico_3">Ejemplo práctico</a></li>
<li><a href="#_buenas_prácticas_6">Buenas prácticas</a></li>
<li><a href="#_resumen_3">Resumen</a></li>
</ul>
</li>
<li><a href="#_montajes_de_enlace_bind_mounts">Montajes de enlace (bind mounts)</a>
<ul class="sectlevel3">
<li><a href="#_cuándo_usar_bind_mounts">¿Cuándo usar bind mounts?</a></li>
<li><a href="#_sintaxis_y_uso_básico">Sintaxis y uso básico</a></li>
<li><a href="#_modo_de_solo_lectura">Modo de solo lectura</a></li>
<li><a href="#_ejemplo_práctico_4">Ejemplo práctico</a></li>
<li><a href="#_consideraciones_de_seguridad_y_permisos_2">Consideraciones de seguridad y permisos</a></li>
<li><a href="#_diferencias_entre_bind_mounts_y_volúmenes">Diferencias entre bind mounts y volúmenes</a></li>
<li><a href="#_buenas_prácticas_7">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_estrategias_de_backup_y_restauración">Estrategias de backup y restauración</a>
<ul class="sectlevel3">
<li><a href="#_backup_y_restauración_de_volúmenes_docker">Backup y restauración de volúmenes Docker</a></li>
<li><a href="#_backup_y_restauración_de_bind_mounts">Backup y restauración de bind mounts</a></li>
<li><a href="#_backup_y_restauración_de_bases_de_datos_en_contenedores">Backup y restauración de bases de datos en contenedores</a></li>
<li><a href="#_automatización_y_buenas_prácticas">Automatización y buenas prácticas</a></li>
<li><a href="#_ejemplo_completo_backup_y_restauración_de_un_volumen">Ejemplo completo: backup y restauración de un volumen</a></li>
<li><a href="#_resumen_4">Resumen</a></li>
</ul>
</li>
<li><a href="#_compartir_datos_entre_contenedores">Compartir datos entre contenedores</a>
<ul class="sectlevel3">
<li><a href="#_compartir_volúmenes_entre_contenedores_2">Compartir volúmenes entre contenedores</a></li>
<li><a href="#_compartir_bind_mounts">Compartir bind mounts</a></li>
<li><a href="#_volúmenes_data_only_contenedores_de_datos">Volúmenes "data-only" (contenedores de datos)</a></li>
<li><a href="#_consideraciones_de_concurrencia_y_permisos">Consideraciones de concurrencia y permisos</a></li>
<li><a href="#_buenas_prácticas_8">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_persistencia_en_entornos_de_producción">Persistencia en entornos de producción</a>
<ul class="sectlevel3">
<li><a href="#_usa_volúmenes_gestionados_por_docker_o_soluciones_externas">Usa volúmenes gestionados por Docker o soluciones externas</a></li>
<li><a href="#_monta_volúmenes_en_rutas_específicas">Monta volúmenes en rutas específicas</a></li>
<li><a href="#_gestiona_permisos_y_usuarios">Gestiona permisos y usuarios</a></li>
<li><a href="#_realiza_backups_y_pruebas_de_restauración_periódicas">Realiza backups y pruebas de restauración periódicas</a></li>
<li><a href="#_monitoriza_el_uso_de_espacio_y_el_rendimiento">Monitoriza el uso de espacio y el rendimiento</a></li>
<li><a href="#_usa_volúmenes_con_cifrado_y_replicación_si_es_necesario">Usa volúmenes con cifrado y replicación si es necesario</a></li>
<li><a href="#_orquestadores_y_almacenamiento_persistente">Orquestadores y almacenamiento persistente</a></li>
<li><a href="#_ejemplo_uso_de_nfs_como_volumen_externo">Ejemplo: uso de NFS como volumen externo</a></li>
<li><a href="#_buenas_prácticas_adicionales">Buenas prácticas adicionales</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_docker_buildx">Docker Buildx</a>
<ul class="sectlevel2">
<li><a href="#_introducción_a_docker_buildx">Introducción a Docker Buildx</a></li>
<li><a href="#_conceptos_fundamentales">Conceptos Fundamentales</a>
<ul class="sectlevel3">
<li><a href="#_arquitectura_cliente_servidor_buildx_cliente_y_buildkit_servidor">Arquitectura cliente-servidor: Buildx (cliente) y BuildKit (servidor)</a></li>
<li><a href="#_qué_es_un_builder_y_para_qué_sirve">Qué es un "builder" y para qué sirve</a></li>
<li><a href="#_drivers_disponibles_docker_docker_container_kubernetes_remote">Drivers disponibles: docker, docker-container, kubernetes, remote</a></li>
</ul>
</li>
<li><a href="#_gestión_de_instancias_de_builder">Gestión de Instancias de Builder</a>
<ul class="sectlevel3">
<li><a href="#_listar_builders_disponibles">Listar builders disponibles</a></li>
<li><a href="#_crear_un_nuevo_builder">Crear un nuevo builder</a></li>
<li><a href="#_cambiar_de_builder">Cambiar de builder</a></li>
<li><a href="#_inspeccionar_un_builder">Inspeccionar un builder</a></li>
<li><a href="#_eliminar_un_builder">Eliminar un builder</a></li>
<li><a href="#_resumen_de_comandos_principales">Resumen de comandos principales</a></li>
</ul>
</li>
<li><a href="#_uso_básico_de_buildx">Uso Básico de Buildx</a>
<ul class="sectlevel3">
<li><a href="#_comando_principal">Comando principal</a></li>
<li><a href="#_opciones_más_comunes">Opciones más comunes</a></li>
<li><a href="#_ejemplos_prácticos">Ejemplos prácticos</a></li>
<li><a href="#_flujo_de_trabajo_resumido">Flujo de trabajo resumido</a></li>
</ul>
</li>
<li><a href="#_ejemplos_prácticos_2">Ejemplos Prácticos</a>
<ul class="sectlevel3">
<li><a href="#_construcción_básica_de_una_imagen">Construcción básica de una imagen</a></li>
<li><a href="#_construcción_multiplataforma">Construcción multiplataforma</a></li>
<li><a href="#_uso_de_compilaciones_multietapa_multi_stage_builds">Uso de compilaciones multietapa (multi-stage builds)</a></li>
<li><a href="#_ejemplo_de_caché_avanzada">Ejemplo de caché avanzada</a></li>
<li><a href="#_automatización_en_cicd">Automatización en CI/CD</a></li>
<li><a href="#_exportar_imágenes_en_diferentes_formatos">Exportar imágenes en diferentes formatos</a></li>
</ul>
</li>
<li><a href="#_funcionalidades_avanzadas">Funcionalidades Avanzadas</a>
<ul class="sectlevel3">
<li><a href="#_construcción_multiplataforma_y_cross_compilation">Construcción multiplataforma y cross-compilation</a></li>
<li><a href="#_optimización_de_builds_multietapa_y_paralelismo">Optimización de builds multietapa y paralelismo</a></li>
<li><a href="#_exportadores_y_outputs_flexibles">Exportadores y outputs flexibles</a></li>
<li><a href="#_gestión_avanzada_de_caché">Gestión avanzada de caché</a></li>
<li><a href="#_ejecución_remota_y_builders_externos">Ejecución remota y builders externos</a></li>
<li><a href="#_buildx_bake_orquestación_de_builds_complejos">buildx bake: orquestación de builds complejos</a></li>
<li><a href="#_buildx_imagetools_gestión_avanzada_de_imágenes_y_manifests">buildx imagetools: gestión avanzada de imágenes y manifests</a></li>
</ul>
</li>
<li><a href="#_buenas_prácticas_y_optimización">Buenas Prácticas y Optimización</a>
<ul class="sectlevel3">
<li><a href="#_optimización_de_builds_multietapa_y_paralelismo_2">Optimización de builds multietapa y paralelismo</a></li>
<li><a href="#_aprovecha_la_caché_avanzada">Aprovecha la caché avanzada</a></li>
<li><a href="#_minimiza_el_contexto_de_build">Minimiza el contexto de build</a></li>
<li><a href="#_mantén_el_dockerfile_simple_y_eficiente">Mantén el Dockerfile simple y eficiente</a></li>
<li><a href="#_usa_etiquetas_y_versiones_explícitas">Usa etiquetas y versiones explícitas</a></li>
<li><a href="#_seguridad_y_secretos">Seguridad y secretos</a></li>
<li><a href="#_medición_y_comparación_de_builds">Medición y comparación de builds</a></li>
</ul>
</li>
<li><a href="#_recursos_y_documentación_para_buildx">Recursos y documentación para buildx</a>
<ul class="sectlevel3">
<li><a href="#_documentación_oficial_de_docker_buildx">Documentación oficial de Docker Buildx</a></li>
<li><a href="#_repositorio_oficial_en_github">Repositorio oficial en GitHub</a></li>
<li><a href="#_comunidad_docker">Comunidad Docker</a></li>
<li><a href="#_subcomandos_y_utilidades_clave">Subcomandos y utilidades clave</a></li>
<li><a href="#_instalación_y_actualización">Instalación y actualización</a></li>
<li><a href="#_consejos_para_profundizar">Consejos para profundizar</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_docker_compose">Docker Compose</a>
<ul class="sectlevel2">
<li><a href="#_introducción_a_docker_compose">Introducción a Docker Compose</a>
<ul class="sectlevel3">
<li><a href="#_ventajas_de_docker_compose">Ventajas de Docker Compose</a></li>
<li><a href="#_cómo_funciona">¿Cómo funciona?</a></li>
<li><a href="#_ejemplo_básico_de_archivo_docker_compose_yml">Ejemplo básico de archivo docker-compose.yml</a></li>
<li><a href="#_comandos_principales_de_docker_compose">Comandos principales de Docker Compose</a></li>
<li><a href="#_buenas_prácticas_9">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_estructura_del_archivo_docker_compose_yml">Estructura del archivo docker-compose.yml</a>
<ul class="sectlevel3">
<li><a href="#_secciones_principales_del_archivo">Secciones principales del archivo</a></li>
<li><a href="#_ejemplo_básico_de_estructura">Ejemplo básico de estructura</a></li>
<li><a href="#_explicación_de_los_elementos">Explicación de los elementos</a></li>
<li><a href="#_opciones_comunes_en_servicios">Opciones comunes en servicios</a></li>
<li><a href="#_ejemplo_avanzado">Ejemplo avanzado</a></li>
<li><a href="#_buenas_prácticas_10">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_definición_de_servicios_redes_y_volúmenes">Definición de servicios, redes y volúmenes</a>
<ul class="sectlevel3">
<li><a href="#_servicios">Servicios</a></li>
<li><a href="#_volúmenes">Volúmenes</a></li>
<li><a href="#_redes">Redes</a></li>
<li><a href="#_ejemplo_completo_de_docker_compose_yml">Ejemplo completo de docker-compose.yml</a></li>
<li><a href="#_buenas_prácticas_11">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_gestión_del_ciclo_de_vida_de_aplicaciones_multi_contenedor">Gestión del ciclo de vida de aplicaciones multi-contenedor</a>
<ul class="sectlevel3">
<li><a href="#_arranque_y_parada_de_la_aplicación">Arranque y parada de la aplicación</a></li>
<li><a href="#_escalado_de_servicios">Escalado de servicios</a></li>
<li><a href="#_actualización_y_recreación_de_servicios">Actualización y recreación de servicios</a></li>
<li><a href="#_monitorización_y_logs">Monitorización y logs</a></li>
<li><a href="#_parada_reinicio_y_eliminación_selectiva">Parada, reinicio y eliminación selectiva</a></li>
<li><a href="#_actualización_de_la_configuración">Actualización de la configuración</a></li>
<li><a href="#_buenas_prácticas_12">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_entornos_de_desarrollo_vs_producción">Entornos de desarrollo vs. producción</a>
<ul class="sectlevel3">
<li><a href="#_objetivos_y_prioridades">Objetivos y prioridades</a></li>
<li><a href="#_configuración_de_servicios">Configuración de servicios</a></li>
<li><a href="#_variables_de_entorno_y_secretos">Variables de entorno y secretos</a></li>
<li><a href="#_seguridad">Seguridad</a></li>
<li><a href="#_escalabilidad_y_orquestación">Escalabilidad y orquestación</a></li>
<li><a href="#_monitorización_y_logging">Monitorización y logging</a></li>
<li><a href="#_actualización_y_despliegue">Actualización y despliegue</a></li>
<li><a href="#_buenas_prácticas_13">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_docker_swarm_mode">Docker Swarm mode</a>
<ul class="sectlevel2">
<li><a href="#_introducción_a_docker_swarm">Introducción a Docker Swarm</a>
<ul class="sectlevel3">
<li><a href="#_características_principales_de_docker_swarm">Características principales de Docker Swarm</a></li>
<li><a href="#_cuándo_usar_docker_swarm">¿Cuándo usar Docker Swarm?</a></li>
<li><a href="#_conceptos_clave">Conceptos clave</a></li>
<li><a href="#_ejemplo_de_flujo_básico_con_docker_swarm">Ejemplo de flujo básico con Docker Swarm</a></li>
</ul>
</li>
<li><a href="#_configuración_de_un_clúster_swarm">Configuración de un clúster Swarm</a>
<ul class="sectlevel3">
<li><a href="#_requisitos_previos">Requisitos previos</a></li>
<li><a href="#_inicializar_el_clúster_swarm">Inicializar el clúster Swarm</a></li>
<li><a href="#_añadir_nodos_workers_al_clúster">Añadir nodos workers al clúster</a></li>
<li><a href="#_verificar_el_estado_del_clúster">Verificar el estado del clúster</a></li>
<li><a href="#_añadir_nodos_manager_adicionales_alta_disponibilidad">Añadir nodos manager adicionales (alta disponibilidad)</a></li>
<li><a href="#_configuración_de_redes_overlay">Configuración de redes overlay</a></li>
<li><a href="#_buenas_prácticas_14">Buenas prácticas</a></li>
<li><a href="#_resumen_del_flujo_de_configuración">Resumen del flujo de configuración</a></li>
</ul>
</li>
<li><a href="#_gestión_de_servicios_y_tareas">Gestión de servicios y tareas</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_un_servicio_en_swarm">¿Qué es un servicio en Swarm?</a></li>
<li><a href="#_qué_es_una_tarea">¿Qué es una tarea?</a></li>
<li><a href="#_comandos_esenciales_para_la_gestión">Comandos esenciales para la gestión</a></li>
<li><a href="#_inspección_y_control_avanzado">Inspección y control avanzado</a></li>
<li><a href="#_buenas_prácticas_15">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_escalado_y_balanceo_de_carga">Escalado y balanceo de carga</a>
<ul class="sectlevel3">
<li><a href="#_escalado_de_servicios_2">Escalado de servicios</a></li>
<li><a href="#_balanceo_de_carga_interno">Balanceo de carga interno</a></li>
<li><a href="#_balanceo_de_carga_externo">Balanceo de carga externo</a></li>
<li><a href="#_actualización_dinámica_del_escalado">Actualización dinámica del escalado</a></li>
<li><a href="#_ver_el_estado_de_las_réplicas">Ver el estado de las réplicas</a></li>
<li><a href="#_buenas_prácticas_16">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_actualizaciones_y_rollbacks_de_servicios">Actualizaciones y rollbacks de servicios</a>
<ul class="sectlevel3">
<li><a href="#_actualizaciones_rolling_updates">Actualizaciones (Rolling Updates)</a></li>
<li><a href="#_rollback_reversión_de_servicios">Rollback (reversión de servicios)</a></li>
<li><a href="#_políticas_de_actualización_y_rollback">Políticas de actualización y rollback</a></li>
<li><a href="#_ver_el_historial_y_estado_de_actualizaciones">Ver el historial y estado de actualizaciones</a></li>
<li><a href="#_buenas_prácticas_17">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_redes_y_volúmenes_en_swarm">Redes y volúmenes en Swarm</a>
<ul class="sectlevel3">
<li><a href="#_redes_en_swarm">Redes en Swarm</a></li>
<li><a href="#_volúmenes_en_swarm">Volúmenes en Swarm</a></li>
<li><a href="#_buenas_prácticas_18">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_docker_en_producción">Docker en Producción</a>
<ul class="sectlevel2">
<li><a href="#_consideraciones_de_seguridad">Consideraciones de seguridad</a>
<ul class="sectlevel3">
<li><a href="#_principio_de_mínimo_privilegio">Principio de mínimo privilegio</a></li>
<li><a href="#_actualización_y_escaneo_de_imágenes">Actualización y escaneo de imágenes</a></li>
<li><a href="#_reducción_de_superficie_de_ataque">Reducción de superficie de ataque</a></li>
<li><a href="#_gestión_segura_de_secretos">Gestión segura de secretos</a></li>
<li><a href="#_aislamiento_de_redes_y_servicios">Aislamiento de redes y servicios</a></li>
<li><a href="#_control_de_acceso_y_auditoría">Control de acceso y auditoría</a></li>
<li><a href="#_protección_del_daemon_docker">Protección del daemon Docker</a></li>
<li><a href="#_actualización_y_parches_del_host">Actualización y parches del host</a></li>
<li><a href="#_buenas_prácticas_adicionales_2">Buenas prácticas adicionales</a></li>
</ul>
</li>
<li><a href="#_rendimiento_y_escalabilidad">Rendimiento y escalabilidad</a>
<ul class="sectlevel3">
<li><a href="#_optimización_de_imágenes">Optimización de imágenes</a></li>
<li><a href="#_asignación_y_limitación_de_recursos">Asignación y limitación de recursos</a></li>
<li><a href="#_escalabilidad_horizontal">Escalabilidad horizontal</a></li>
<li><a href="#_almacenamiento_eficiente">Almacenamiento eficiente</a></li>
<li><a href="#_redes_y_comunicación">Redes y comunicación</a></li>
<li><a href="#_monitorización_y_ajuste_de_recursos">Monitorización y ajuste de recursos</a></li>
<li><a href="#_buenas_prácticas_19">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_monitorización_y_logging_2">Monitorización y logging</a>
<ul class="sectlevel3">
<li><a href="#_monitorización_de_contenedores">Monitorización de contenedores</a></li>
<li><a href="#_logging_de_contenedores">Logging de contenedores</a></li>
<li><a href="#_centralización_de_logs">Centralización de logs</a></li>
<li><a href="#_buenas_prácticas_de_monitorización_y_logging">Buenas prácticas de monitorización y logging</a></li>
<li><a href="#_ejemplo_de_stack_de_monitorización_y_logging">Ejemplo de stack de monitorización y logging</a></li>
</ul>
</li>
<li><a href="#_estrategias_de_despliegue">Estrategias de despliegue</a>
<ul class="sectlevel3">
<li><a href="#_despliegue_tradicional_stop_start">Despliegue tradicional (stop &amp; start)</a></li>
<li><a href="#_rolling_update_actualización_escalonada">Rolling Update (actualización escalonada)</a></li>
<li><a href="#_bluegreen_deployment">Blue/Green Deployment</a></li>
<li><a href="#_canary_deployment">Canary Deployment</a></li>
<li><a href="#_zero_downtime_deployment">Zero Downtime Deployment</a></li>
<li><a href="#_automatización_del_despliegue">Automatización del despliegue</a></li>
<li><a href="#_buenas_prácticas_20">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_docker_swarm_orquestación_básica">Docker Swarm (orquestación básica)</a>
<ul class="sectlevel3">
<li><a href="#_características_principales">Características principales</a></li>
<li><a href="#_flujo_básico_de_uso">Flujo básico de uso</a></li>
<li><a href="#_buenas_prácticas_21">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_integración_continua_y_entrega_continua_cicd">Integración Continua y Entrega Continua (CI/CD)</a>
<ul class="sectlevel2">
<li><a href="#_docker_en_pipelines_de_cicd">Docker en pipelines de CI/CD</a>
<ul class="sectlevel3">
<li><a href="#_ventajas_de_usar_docker_en_cicd">Ventajas de usar Docker en CI/CD</a></li>
<li><a href="#_flujo_típico_de_un_pipeline_cicd_con_docker">Flujo típico de un pipeline CI/CD con Docker</a></li>
<li><a href="#_ejemplo_básico_de_pipeline_pseudocódigo">Ejemplo básico de pipeline (pseudocódigo)</a></li>
<li><a href="#_integración_con_herramientas_populares">Integración con herramientas populares</a></li>
<li><a href="#_buenas_prácticas_22">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_automatización_de_builds_y_tests">Automatización de builds y tests</a>
<ul class="sectlevel3">
<li><a href="#_build_automatizado_de_imágenes">Build automatizado de imágenes</a></li>
<li><a href="#_ejecución_de_tests_en_contenedores">Ejecución de tests en contenedores</a></li>
<li><a href="#_limpieza_automática">Limpieza automática</a></li>
<li><a href="#_buenas_prácticas_23">Buenas prácticas</a></li>
<li><a href="#_ejemplo_de_workflow_en_github_actions">Ejemplo de workflow en GitHub Actions</a></li>
</ul>
</li>
<li><a href="#_despliegue_automático_de_contenedores">Despliegue automático de contenedores</a>
<ul class="sectlevel3">
<li><a href="#_flujo_típico_de_despliegue_automático">Flujo típico de despliegue automático</a></li>
<li><a href="#_ejemplo_de_despliegue_automático_con_docker_compose">Ejemplo de despliegue automático con Docker Compose</a></li>
<li><a href="#_ejemplo_de_despliegue_automático_en_swarm">Ejemplo de despliegue automático en Swarm</a></li>
<li><a href="#_integración_con_pipelines_cicd">Integración con pipelines CI/CD</a></li>
<li><a href="#_buenas_prácticas_24">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_integración_con_herramientas_como_jenkins_github_actions_etc">Integración con herramientas como Jenkins, GitHub Actions, etc.</a>
<ul class="sectlevel3">
<li><a href="#_jenkins">Jenkins</a></li>
<li><a href="#_github_actions">GitHub Actions</a></li>
<li><a href="#_gitlab_ci">GitLab CI</a></li>
<li><a href="#_otras_herramientas">Otras herramientas</a></li>
<li><a href="#_buenas_prácticas_25">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_recursos_adicionales_2">Recursos Adicionales</a>
<ul class="sectlevel2">
<li><a href="#_documentación_oficial">Documentación oficial</a></li>
<li><a href="#_comunidad_y_soporte">Comunidad y soporte</a></li>
<li><a href="#_herramientas_complementarias">Herramientas complementarias</a></li>
<li><a href="#_tendencias_y_futuro_de_docker">Tendencias y futuro de Docker</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introducción_a_docker">Introducción a Docker</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_conceptos_básicos_de_contenedores_y_virtualización">Conceptos básicos de contenedores y virtualización</h3>
<div class="sect3">
<h4 id="_qué_es_la_virtualización">¿Qué es la virtualización?</h4>
<div class="paragraph">
<p>La virtualización es una tecnología que permite ejecutar múltiples sistemas operativos y aplicaciones en un solo servidor físico, creando entornos virtuales independientes llamados máquinas virtuales (VMs). Cada VM tiene su propio sistema operativo, recursos asignados (CPU, memoria, almacenamiento) y funciona de manera aislada respecto a las demás.</p>
</div>
<div class="ulist">
<div class="title"><strong>Ventajas de la virtualización tradicional:</strong></div>
<ul>
<li>
<p>Aislamiento total entre entornos.</p>
</li>
<li>
<p>Mejor aprovechamiento del hardware.</p>
</li>
<li>
<p>Facilidad para crear, clonar y migrar entornos.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title"><strong>Desventajas:</strong></div>
<ul>
<li>
<p>Consumo elevado de recursos, ya que cada VM ejecuta un sistema operativo completo.</p>
</li>
<li>
<p>Arranque más lento comparado con otras tecnologías.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_qué_es_un_contenedor">¿Qué es un contenedor?</h4>
<div class="paragraph">
<p>Un contenedor es una unidad ligera y portátil que permite empaquetar una aplicación junto con todas sus dependencias (librerías, configuraciones, binarios) en un solo paquete. A diferencia de las VMs, los contenedores comparten el núcleo del sistema operativo del host, pero mantienen el aislamiento a nivel de proceso y sistema de archivos.</p>
</div>
<div class="ulist">
<div class="title"><strong>Ventajas de los contenedores:</strong></div>
<ul>
<li>
<p>Arranque casi instantáneo.</p>
</li>
<li>
<p>Menor consumo de recursos.</p>
</li>
<li>
<p>Portabilidad entre diferentes entornos (desarrollo, pruebas, producción).</p>
</li>
<li>
<p>Facilidad para escalar y orquestar aplicaciones.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Diferencias clave entre contenedores y máquinas virtuales:</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Contenedores</th>
<th class="tableblock halign-left valign-top">Máquinas Virtuales</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comparten el kernel del host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada VM tiene su propio kernel</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arranque en segundos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arranque en minutos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bajo consumo de recursos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mayor consumo de recursos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ideal para microservicios</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ideal para aplicaciones monolíticas o legacy</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_cómo_funcionan_los_contenedores">¿Cómo funcionan los contenedores?</h4>
<div class="paragraph">
<p>Los contenedores utilizan tecnologías del sistema operativo como namespaces y cgroups (en Linux) para aislar procesos, limitar recursos y proporcionar un entorno seguro y controlado. Todo lo necesario para ejecutar la aplicación se incluye en la imagen del contenedor.</p>
</div>
<div class="olist arabic">
<div class="title"><strong>Ejemplo de ciclo de vida de un contenedor:</strong></div>
<ol class="arabic">
<li>
<p>El desarrollador crea una imagen con la aplicación y sus dependencias.</p>
</li>
<li>
<p>El usuario ejecuta un contenedor a partir de esa imagen.</p>
</li>
<li>
<p>El contenedor se ejecuta de forma aislada, pero puede comunicarse con otros contenedores o el exterior si se configura.</p>
</li>
<li>
<p>Al detener el contenedor, los procesos se eliminan, pero la imagen permanece disponible para futuros usos.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_diferencias_entre_vm_y_contenedor">Ejemplo práctico: diferencias entre VM y contenedor</h4>
<div class="paragraph">
<p><strong>Ejemplo de comando para crear una VM (usando VirtualBox):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">VBoxManage createvm --name "mi_vm" --register
VBoxManage modifyvm "mi_vm" --memory 2048 --acpi on --boot1 dvd --nic1 nat
VBoxManage createhd --filename "mi_vm.vdi" --size 10000</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Ejemplo de comando para crear y ejecutar un contenedor Docker:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name mi_contenedor nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como puedes ver, crear y ejecutar un contenedor es mucho más sencillo y rápido que una VM.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico">Resumen gráfico</h4>
<div class="listingblock">
<div class="content">
<pre>@startuml
actor Usuario
Usuario -&gt; Docker: docker run nginx
Docker -&gt; Kernel Host: Solicita recursos
Kernel Host -&gt; Docker: Asigna recursos
Docker -&gt; Contenedor: Inicia proceso aislado
Contenedor -&gt; Usuario: Servicio disponible
@enduml</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_historia_y_evolución_de_docker">Historia y evolución de Docker</h3>
<div class="sect3">
<h4 id="_orígenes_de_docker">Orígenes de Docker</h4>
<div class="paragraph">
<p>Docker fue presentado públicamente en marzo de 2013 por Solomon Hykes, como un proyecto interno de la empresa dotCloud. Su objetivo era facilitar el despliegue y la portabilidad de aplicaciones, resolviendo problemas comunes en el desarrollo y la operación de software, como la famosa frase "en mi máquina funciona".</p>
</div>
<div class="paragraph">
<p>Antes de Docker, existían tecnologías de contenedores en Linux como LXC (Linux Containers), pero eran complejas de usar y carecían de una experiencia de usuario sencilla y estandarizada. Docker simplificó el uso de contenedores al proporcionar una interfaz fácil de usar, herramientas de automatización y un formato de empaquetado universal: la imagen Docker.</p>
</div>
</div>
<div class="sect3">
<h4 id="_línea_de_tiempo_de_hitos_importantes">Línea de tiempo de hitos importantes</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Año</th>
<th class="tableblock halign-left valign-top">Hito</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2013</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lanzamiento de Docker como proyecto open source. Uso inicial de LXC como backend.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2014</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Docker 1.0. Se introduce el formato de imágenes y el registro público Docker Hub.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2015</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Docker reemplaza LXC por su propia biblioteca de ejecución: <code>libcontainer</code> (ahora runc).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2016</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nacen proyectos del ecosistema: Docker Compose (orquestación simple), Docker Swarm (clustering).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2017</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Se crea la Open Container Initiative (OCI) para estandarizar imágenes y runtimes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes se consolida como el orquestador de contenedores dominante, compatible con Docker.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2020</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Docker Inc. se enfoca en herramientas para desarrolladores, y el runtime de Docker se desacopla de Kubernetes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2023</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Docker sigue siendo la herramienta de referencia para desarrollo y pruebas con contenedores.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_evolución_tecnológica">Evolución tecnológica</h4>
<div class="ulist">
<ul>
<li>
<p><strong>De LXC a runc</strong>: Docker comenzó usando LXC, pero luego desarrolló su propio runtime (<code>runc</code>), que se convirtió en estándar abierto.</p>
</li>
<li>
<p><strong>Imágenes y capas</strong>: Introdujo el concepto de imágenes por capas, facilitando la reutilización y la eficiencia en la descarga y almacenamiento.</p>
</li>
<li>
<p><strong>Docker Hub</strong>: Primer registro público de imágenes, permitiendo compartir y reutilizar aplicaciones de manera global.</p>
</li>
<li>
<p><strong>Herramientas complementarias</strong>: Docker Compose para definir aplicaciones multicontenedor, Docker Swarm para orquestación nativa, y compatibilidad con Kubernetes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_impacto_en_la_industria">Impacto en la industria</h4>
<div class="ulist">
<div class="title">Docker revolucionó la forma en que se desarrollan, prueban y despliegan aplicaciones:</div>
<ul>
<li>
<p>Aceleró la adopción de microservicios y DevOps.</p>
</li>
<li>
<p>Facilitó la integración continua y entrega continua (CI/CD).</p>
</li>
<li>
<p>Mejoró la portabilidad entre entornos (desarrollo, pruebas, producción, nube).</p>
</li>
<li>
<p>Impulsó la estandarización de contenedores a través de la OCI.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_primer_comando_histórico_de_docker">Ejemplo: primer comando histórico de Docker</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run hello-world</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este comando descarga una imagen de prueba y ejecuta un contenedor, demostrando la simplicidad y potencia de Docker desde sus inicios.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico_de_la_evolución">Resumen gráfico de la evolución</h4>
<div class="listingblock">
<div class="content">
<pre>@startuml
:dotCloud;
:dotCloud; -&gt; :Docker (2013);
:Docker (2013); -&gt; :Docker 1.0 (2014);
:Docker 1.0 (2014); -&gt; :Docker Compose/Swarm (2016);
:Docker Compose/Swarm (2016); -&gt; :OCI (2017);
:OCI (2017); -&gt; :Kubernetes Integration (2018);
:Kubernetes Integration (2018); -&gt; :Docker Desktop (2020+);
@enduml</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arquitectura_de_docker">Arquitectura de Docker</h3>
<div class="sect3">
<h4 id="_componentes_principales_de_docker">Componentes principales de Docker</h4>
<div class="paragraph">
<p>Docker está compuesto por varios elementos que trabajan juntos para gestionar contenedores de forma eficiente y segura:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Docker Engine</strong>: Es el núcleo de Docker, responsable de crear, ejecutar y gestionar contenedores. Incluye el demonio (<code>dockerd</code>), la API REST y la CLI.</p>
</li>
<li>
<p><strong>Docker Daemon (<code>dockerd</code>)</strong>: Proceso que corre en segundo plano y gestiona los objetos Docker (imágenes, contenedores, redes, volúmenes).</p>
</li>
<li>
<p><strong>Docker CLI (<code>docker</code>)</strong>: Herramienta de línea de comandos que permite a los usuarios interactuar con Docker Engine.</p>
</li>
<li>
<p><strong>Docker API</strong>: Interfaz RESTful que permite a otras aplicaciones comunicarse con Docker.</p>
</li>
<li>
<p><strong>Docker Images</strong>: Plantillas inmutables que contienen el sistema de archivos y las dependencias necesarias para ejecutar una aplicación.</p>
</li>
<li>
<p><strong>Docker Containers</strong>: Instancias en ejecución de imágenes Docker, aisladas y gestionadas por el Engine.</p>
</li>
<li>
<p><strong>Docker Registry</strong>: Repositorio para almacenar y compartir imágenes (por ejemplo, Docker Hub o registros privados).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_diagrama_de_arquitectura">Diagrama de arquitectura</h4>
<div class="literalblock">
<div class="content">
<pre>@startuml
actor Usuario
Usuario -&gt; CLI: docker run, docker build, etc.
CLI -&gt; API: Solicitudes REST
API -&gt; Daemon: Procesamiento de solicitudes
Daemon -&gt; Registry: pull/push imágenes
Daemon -&gt; Contenedor: Crear/Iniciar/Detener
Daemon -&gt; Volúmenes/Redes: Gestionar recursos
@enduml</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_flujo_de_trabajo_típico">Flujo de trabajo típico</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El usuario ejecuta un comando con la CLI (<code>docker run</code>, <code>docker build</code>, etc.).</p>
</li>
<li>
<p>La CLI se comunica con el Docker Daemon a través de la API.</p>
</li>
<li>
<p>El Daemon gestiona la creación de imágenes, el arranque de contenedores, la configuración de redes y volúmenes.</p>
</li>
<li>
<p>Si es necesario, el Daemon descarga imágenes desde un registro (Docker Hub o privado).</p>
</li>
<li>
<p>El Daemon inicia el contenedor, asignando recursos y configurando el entorno según lo solicitado.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_ciclo_de_vida_de_un_contenedor">Ejemplo práctico: ciclo de vida de un contenedor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Descargar una imagen desde Docker Hub
docker pull nginx

# Crear y ejecutar un contenedor a partir de la imagen
docker run -d --name webserver -p 8080:80 nginx

# Ver los contenedores en ejecución
docker ps

# Detener el contenedor
docker stop webserver

# Eliminar el contenedor
docker rm webserver</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_de_la_arquitectura">Resumen de la arquitectura</h4>
<div class="ulist">
<ul>
<li>
<p>La arquitectura de Docker está diseñada para ser modular, eficiente y segura.</p>
</li>
<li>
<p>Permite la gestión de aplicaciones en contenedores de forma sencilla, facilitando la portabilidad y escalabilidad.</p>
</li>
<li>
<p>El uso de registros de imágenes y la separación entre CLI, Daemon y API permite la integración con herramientas externas y la automatización de flujos DevOps.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_de_la_arquitectura_de_docker">Ventajas de la arquitectura de Docker</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Aislamiento</strong>: Cada contenedor es independiente y seguro.</p>
</li>
<li>
<p><strong>Portabilidad</strong>: Las imágenes pueden ejecutarse en cualquier sistema con Docker Engine.</p>
</li>
<li>
<p><strong>Escalabilidad</strong>: Fácil de integrar con orquestadores como Docker Swarm o Kubernetes.</p>
</li>
<li>
<p><strong>Automatización</strong>: Integración sencilla con pipelines de CI/CD y herramientas de infraestructura como código.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instalación_de_docker_y_alternativas_a_docker">Instalación de Docker y alternativas a Docker</h3>
<div class="sect3">
<h4 id="_instalación_de_docker_en_diferentes_sistemas_operativos">Instalación de Docker en diferentes sistemas operativos</h4>
<div class="paragraph">
<p>Docker puede instalarse en la mayoría de los sistemas operativos modernos. A continuación se detallan los pasos para los entornos más comunes:</p>
</div>
<div class="sect4">
<h5 id="_instalación_en_linux_ubuntudebian">Instalación en Linux (Ubuntu/Debian)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">sudo apt update
sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io
sudo systemctl enable --now docker
sudo usermod -aG docker $USER
# Cierra sesión y vuelve a entrar para que el grupo 'docker' tenga efecto</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_instalación_en_centosrhel">Instalación en CentOS/RHEL</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">sudo yum install -y yum-utils
sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
sudo yum install -y docker-ce docker-ce-cli containerd.io
sudo systemctl enable --now docker
sudo usermod -aG docker $USER</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_instalación_en_windows_y_macos">Instalación en Windows y macOS</h5>
<div class="ulist">
<ul>
<li>
<p>Descarga Docker Desktop desde <a href="https://www.docker.com/products/docker-desktop" class="bare">https://www.docker.com/products/docker-desktop</a></p>
</li>
<li>
<p>Sigue el asistente de instalación.</p>
</li>
<li>
<p>Docker Desktop incluye Docker Engine, Docker CLI, Docker Compose y una interfaz gráfica.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_verificación_de_la_instalación">Verificación de la instalación</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker --version
docker run hello-world</code></pre>
</div>
</div>
<div class="paragraph">
<p>El comando <code>hello-world</code> descarga una imagen de prueba y ejecuta un contenedor para verificar que Docker funciona correctamente.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_alternativas_a_docker">Alternativas a Docker</h4>
<div class="paragraph">
<p>Aunque Docker es la herramienta más popular, existen otras tecnologías de contenedores y runtimes compatibles con el estándar OCI (Open Container Initiative):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Alternativa</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Podman</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Herramienta compatible con la CLI de Docker, pero sin daemon centralizado. Permite ejecutar contenedores rootless (sin privilegios de root).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">containerd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Runtime de contenedores ligero, utilizado internamente por Docker y Kubernetes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CRI-O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Runtime optimizado para Kubernetes, compatible con imágenes OCI.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LXC/LXD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contenedores de sistema completos, más cercanos a las máquinas virtuales ligeras.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rkt (Rocket)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Proyecto de CoreOS, ahora discontinuado, que buscaba ser una alternativa a Docker.</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_ejemplo_uso_básico_de_podman">Ejemplo: uso básico de Podman</h5>
<div class="paragraph">
<p>Podman es muy similar a Docker en su uso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">podman run -d --name mi_contenedor nginx
podman ps
podman stop mi_contenedor</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_diferencias_clave_entre_docker_y_podman">Diferencias clave entre Docker y Podman</h5>
<div class="ulist">
<ul>
<li>
<p>Podman no requiere un daemon centralizado.</p>
</li>
<li>
<p>Permite ejecutar contenedores sin privilegios de root.</p>
</li>
<li>
<p>Compatible con la mayoría de los comandos de Docker.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consideraciones_de_seguridad_y_permisos">Consideraciones de seguridad y permisos</h4>
<div class="ulist">
<ul>
<li>
<p>Es recomendable no ejecutar contenedores como root.</p>
</li>
<li>
<p>Docker Desktop en Windows/macOS utiliza una máquina virtual ligera para ejecutar el motor de Docker.</p>
</li>
<li>
<p>En entornos empresariales, evalúa alternativas como Podman para mayor seguridad y cumplimiento.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p>Docker es la opción más extendida y fácil de usar para comenzar con contenedores.</p>
</li>
<li>
<p>Existen alternativas como Podman, containerd y CRI-O, especialmente útiles en entornos de producción y Kubernetes.</p>
</li>
<li>
<p>La instalación de Docker es sencilla y está bien documentada para todos los sistemas operativos principales.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_primeros_pasos_comandos_básicos">Primeros pasos: comandos básicos</h3>
<div class="paragraph">
<p>En este apartado aprenderás los comandos esenciales para comenzar a trabajar con Docker desde la terminal. Estos comandos te permitirán descargar imágenes, crear y gestionar contenedores, así como inspeccionar el estado de tu entorno Docker.</p>
</div>
<div class="sect3">
<h4 id="_descargar_y_ejecutar_tu_primer_contenedor">Descargar y ejecutar tu primer contenedor</h4>
<div class="listingblock">
<div class="title">El siguiente comando descarga la imagen <code>hello-world</code> desde Docker Hub y ejecuta un contenedor que imprime un mensaje de bienvenida:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run hello-world</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_listar_imágenes_y_contenedores">Listar imágenes y contenedores</h4>
<div class="listingblock">
<div class="title">Para ver las imágenes descargadas en tu sistema:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker images</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para listar los contenedores en ejecución:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker ps</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para ver todos los contenedores (incluidos los detenidos):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker ps -a</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_descargar_imágenes_desde_docker_hub">Descargar imágenes desde Docker Hub</h4>
<div class="listingblock">
<div class="title">Puedes descargar cualquier imagen pública usando el comando <code>pull</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker pull nginx
docker pull ubuntu:22.04</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_crear_y_ejecutar_un_contenedor">Crear y ejecutar un contenedor</h4>
<div class="listingblock">
<div class="title">Ejecuta un contenedor en segundo plano (modo "detached") y mapea el puerto 8080 del host al 80 del contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name webserver -p 8080:80 nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_acceder_a_un_contenedor_en_ejecución">Acceder a un contenedor en ejecución</h4>
<div class="listingblock">
<div class="title">Para abrir una terminal interactiva dentro de un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec -it webserver bash
# Si el contenedor no tiene bash, puedes usar sh:
docker exec -it webserver sh</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_detener_y_eliminar_contenedores">Detener y eliminar contenedores</h4>
<div class="listingblock">
<div class="title">Detener un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker stop webserver</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker rm webserver</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eliminar_imágenes">Eliminar imágenes</h4>
<div class="listingblock">
<div class="title">Para eliminar una imagen que no esté en uso por ningún contenedor, usa el siguiente comando:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker rmi nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ver_logs_de_un_contenedor">Ver logs de un contenedor</h4>
<div class="listingblock">
<div class="title">Para ver los logs de un contenedor en ejecución, puedes usar el siguiente comando:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker logs webserver</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_de_comandos_básicos">Resumen de comandos básicos</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Comando</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker run imagen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ejecuta un contenedor a partir de una imagen</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker ps</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lista los contenedores en ejecución</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker ps -a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lista todos los contenedores</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker images</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lista las imágenes locales</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker pull imagen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descarga una imagen desde Docker Hub</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker stop id/nombre</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Detiene un contenedor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker rm id/nombre</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elimina un contenedor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker rmi imagen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elimina una imagen</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker exec -it id/nombre bash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Accede a la terminal de un contenedor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker logs id/nombre</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Muestra los logs de un contenedor</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_ciclo_de_vida_de_un_contenedor_2">Ejemplo práctico: ciclo de vida de un contenedor</h4>
<div class="listingblock">
<div class="title">En este ejemplo, descargaremos la imagen de nginx, crearemos un contenedor, lo ejecutaremos y luego lo detendremos y eliminaremos.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Descargar la imagen de nginx
docker pull nginx

# Crear y ejecutar el contenedor
docker run -d --name miweb -p 8080:80 nginx

# Verificar que está en ejecución
docker ps

# Acceder al contenedor
docker exec -it miweb bash

# Detener y eliminar el contenedor
docker stop miweb
docker rm miweb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estos comandos te permitirán empezar a trabajar con Docker de manera práctica y efectiva.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_imágenes_y_contenedores_docker">Imágenes y Contenedores Docker</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Una imagen Docker es una plantilla inmutable que contiene todo lo necesario para ejecutar una aplicación: código, dependencias, variables de entorno y archivos de configuración. Las imágenes se construyen en capas, lo que permite la reutilización y eficiencia en el almacenamiento y la transferencia.</p>
</div>
<div class="sect2">
<h3 id="_entendiendo_las_imágenes_docker">Entendiendo las imágenes Docker</h3>
<div class="paragraph">
<p>Una imagen Docker es una plantilla inmutable que contiene todo lo necesario para ejecutar una aplicación: el código fuente, las dependencias, las variables de entorno y los archivos de configuración. Las imágenes son el punto de partida para crear contenedores y se construyen en capas, lo que permite eficiencia y reutilización.</p>
</div>
<div class="sect3">
<h4 id="_características_principales_de_las_imágenes_docker">Características principales de las imágenes Docker</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Inmutabilidad</strong>: Una vez creada, la imagen no cambia. Esto garantiza que los entornos sean reproducibles.</p>
</li>
<li>
<p><strong>Portabilidad</strong>: Una imagen puede ejecutarse en cualquier sistema que tenga Docker Engine, sin importar el sistema operativo subyacente.</p>
</li>
<li>
<p><strong>Eficiencia</strong>: Las imágenes se construyen en capas. Si varias imágenes comparten capas, Docker solo almacena una copia de cada capa, ahorrando espacio y acelerando descargas.</p>
</li>
<li>
<p><strong>Versionado</strong>: Las imágenes pueden tener múltiples etiquetas (tags) para identificar versiones o variantes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_dockerfile">Dockerfile</h4>
<div class="paragraph">
<p>Un Dockerfile es un archivo de texto que contiene una serie de instrucciones para construir una imagen Docker. Define cómo se debe configurar el entorno, qué software instalar y cómo ejecutar la aplicación.</p>
</div>
<div class="ulist">
<div class="title">EL archivo Dockerfile contiene instrucciones que Docker utiliza para construir una imagen. Aquí tienes un resumen de las instrucciones más comunes:</div>
<ul>
<li>
<p><strong>FROM</strong>: Especifica la imagen base sobre la que se construirá la nueva imagen. Es el primer comando de cualquier Dockerfile.</p>
</li>
<li>
<p><strong>LABEL</strong>: Añade metadatos a la imagen en formato clave=valor, como el autor, la versión, etc.</p>
</li>
<li>
<p><strong>RUN</strong>: Ejecuta comandos en la imagen durante el proceso de construcción, por ejemplo instalar paquetes o crear archivos y directorios.</p>
</li>
<li>
<p><strong>CMD</strong>: Define el comando por defecto que se ejecutará cuando se inicie un contenedor a partir de la imagen. Solo puede haber uno; si hay varios, solo el último tiene efecto.</p>
</li>
<li>
<p><strong>EXPOSE</strong>: Indica qué puertos estarán disponibles para exponer en el contenedor. Es informativo y no abre realmente los puertos.</p>
</li>
<li>
<p><strong>ENV</strong>: Establece variables de entorno en la imagen, que estarán disponibles para los procesos que se ejecuten en el contenedor.</p>
</li>
<li>
<p><strong>ADD</strong>: Copia archivos y directorios desde el contexto de construcción al sistema de archivos de la imagen. Además, permite copiar desde URLs y descomprime archivos comprimidos automáticamente.</p>
</li>
<li>
<p><strong>COPY</strong>: Copia archivos y directorios desde el contexto de construcción al sistema de archivos de la imagen, pero sin las funcionalidades adicionales de ADD.</p>
</li>
<li>
<p><strong>ENTRYPOINT</strong>: Define el ejecutable principal que se ejecutará cuando se inicie el contenedor, permitiendo que el contenedor actúe como un comando o servicio específico.</p>
</li>
<li>
<p><strong>VOLUME</strong>: Crea un punto de montaje para volúmenes, permitiendo el almacenamiento persistente de datos fuera del contenedor.</p>
</li>
<li>
<p><strong>WORKDIR</strong>: Establece el directorio de trabajo para las siguientes instrucciones RUN, CMD, ENTRYPOINT, COPY y ADD.</p>
</li>
<li>
<p><strong>USER</strong>: Especifica el usuario y grupo con el que se ejecutarán las siguientes instrucciones del Dockerfile y los procesos del contenedor.</p>
</li>
<li>
<p><strong>ARG</strong>: Define variables que pueden pasarse durante el proceso de construcción de la imagen (build-time variables), pero no estarán disponibles en tiempo de ejecución.</p>
</li>
<li>
<p><strong>ONBUILD</strong>: Especifica instrucciones que se ejecutarán cuando la imagen resultante se use como base para otra imagen (útil para imágenes base personalizadas).</p>
</li>
<li>
<p><strong>SHELL</strong>: Cambia el intérprete de comandos por defecto para las instrucciones RUN, CMD y ENTRYPOINT.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_estructura_de_una_imagen_docker">Estructura de una imagen Docker</h4>
<div class="paragraph">
<p>Cada imagen está formada por una serie de capas apiladas. Cada instrucción en un Dockerfile (como <code>RUN</code>, <code>COPY</code>, <code>ADD</code>) crea una nueva capa. Cuando se actualiza una imagen, solo se descargan las capas nuevas o modificadas.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@startuml
start
:FROM ubuntu:22.04;
:RUN apt-get update;
:COPY . /app;
:RUN pip install -r requirements.txt;
:CMD ["python", "app.py"];
stop
@enduml</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_listar_imágenes_disponibles">Ejemplo: listar imágenes disponibles</h4>
<div class="paragraph">
<p>Para ver las imágenes almacenadas localmente en tu sistema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker images</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Output esperado:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">REPOSITORY</th>
<th class="tableblock halign-left valign-top">TAG</th>
<th class="tableblock halign-left valign-top">IMAGE ID</th>
<th class="tableblock halign-left valign-top">CREATED</th>
<th class="tableblock halign-left valign-top">SIZE</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ubuntu</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">22.04</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">123abc456def</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 weeks ago</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">77MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nginx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">latest</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">789def123abc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 days ago</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">133MB</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_descargar_una_imagen_desde_docker_hub">Descargar una imagen desde Docker Hub</h4>
<div class="paragraph">
<p>Puedes descargar imágenes públicas usando el comando <code>pull</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker pull nginx
docker pull ubuntu:22.04</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inspeccionar_una_imagen">Inspeccionar una imagen</h4>
<div class="paragraph">
<p>Para ver los detalles y metadatos de una imagen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker inspect nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto muestra información como las capas, variables de entorno, comandos de inicio y más.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_uso_de_una_imagen">Ejemplo de uso de una imagen</h4>
<div class="paragraph">
<p>Para ejecutar un contenedor a partir de una imagen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name miweb -p 8080:80 nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_al_trabajar_con_imágenes">Buenas prácticas al trabajar con imágenes</h4>
<div class="ulist">
<ul>
<li>
<p>Utiliza imágenes oficiales y mantenidas siempre que sea posible.</p>
</li>
<li>
<p>Mantén tus imágenes actualizadas para evitar vulnerabilidades.</p>
</li>
<li>
<p>Elimina imágenes que no uses con <code>docker rmi &lt;imagen&gt;</code> para ahorrar espacio.</p>
</li>
<li>
<p>Usa etiquetas (<code>tags</code>) para identificar versiones específicas y evitar sorpresas en producción.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_contenedores">Gestión de contenedores</h3>
<div class="paragraph">
<p>La gestión de contenedores es una de las tareas fundamentales al trabajar con Docker. Un contenedor es una instancia en ejecución de una imagen, y su ciclo de vida puede ser gestionado mediante una serie de comandos que permiten crearlo, iniciarlo, detenerlo, reiniciarlo, eliminarlo y monitorizarlo.</p>
</div>
<div class="sect3">
<h4 id="_crear_y_ejecutar_contenedores">Crear y ejecutar contenedores</h4>
<div class="listingblock">
<div class="title">Para crear y ejecutar un contenedor a partir de una imagen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name mi_contenedor nginx</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-d</code>: Ejecuta el contenedor en segundo plano (detached).</p>
</li>
<li>
<p><code>--name</code>: Asigna un nombre personalizado al contenedor.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_listar_contenedores">Listar contenedores</h4>
<div class="listingblock">
<div class="title">Para ver los contenedores en ejecución:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker ps</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para ver todos los contenedores, incluidos los detenidos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker ps -a</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_detener_iniciar_y_reiniciar_contenedores">Detener, iniciar y reiniciar contenedores</h4>
<div class="listingblock">
<div class="title">Detener un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker stop mi_contenedor</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Iniciar un contenedor detenido:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker start mi_contenedor</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Reiniciar un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker restart mi_contenedor</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eliminar_contenedores">Eliminar contenedores</h4>
<div class="listingblock">
<div class="title">Para eliminar un contenedor detenido:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker rm mi_contenedor</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para eliminar varios contenedores a la vez:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker rm contenedor1 contenedor2 contenedor3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inspeccionar_contenedores">Inspeccionar contenedores</h4>
<div class="listingblock">
<div class="title">Puedes obtener información detallada sobre un contenedor (configuración, red, volúmenes, etc.):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker inspect mi_contenedor</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ver_el_uso_de_recursos_de_los_contenedores">Ver el uso de recursos de los contenedores</h4>
<div class="listingblock">
<div class="title">Para monitorizar el consumo de CPU, memoria y red de los contenedores en tiempo real:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker stats</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_copiar_archivos_entre_el_host_y_el_contenedor">Copiar archivos entre el host y el contenedor</h4>
<div class="listingblock">
<div class="title">Copiar un archivo del host al contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker cp archivo.txt mi_contenedor:/ruta/destino/</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Copiar un archivo del contenedor al host:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker cp mi_contenedor:/ruta/origen/archivo.txt ./</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_gestión_completa_de_un_contenedor">Ejemplo práctico: gestión completa de un contenedor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Descargar la imagen de nginx
docker pull nginx

# Crear y ejecutar el contenedor
docker run -d --name webtest -p 8080:80 nginx

# Verificar que está en ejecución
docker ps

# Detener el contenedor
docker stop webtest

# Iniciar el contenedor nuevamente
docker start webtest

# Eliminar el contenedor
docker stop webtest
docker rm webtest</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_en_la_gestión_de_contenedores">Buenas prácticas en la gestión de contenedores</h4>
<div class="ulist">
<ul>
<li>
<p>Asigna nombres descriptivos a los contenedores para facilitar su identificación.</p>
</li>
<li>
<p>Elimina contenedores que ya no utilices para liberar recursos.</p>
</li>
<li>
<p>Utiliza etiquetas y variables de entorno para personalizar el comportamiento de los contenedores.</p>
</li>
<li>
<p>Supervisa el uso de recursos para evitar cuellos de botella en el sistema.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La correcta gestión de contenedores es clave para mantener entornos de desarrollo y producción ordenados, eficientes y seguros.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ciclo_de_vida_de_un_contenedor">Ciclo de vida de un contenedor</h3>
<div class="paragraph">
<p>El ciclo de vida de un contenedor Docker abarca todas las etapas por las que pasa un contenedor, desde su creación hasta su eliminación. Comprender este ciclo es fundamental para gestionar aplicaciones de manera eficiente y automatizada.</p>
</div>
<div class="sect3">
<h4 id="_etapas_del_ciclo_de_vida">Etapas del ciclo de vida</h4>
<div class="paragraph">
<p><strong>Creación</strong>
.El contenedor se crea a partir de una imagen, pero aún no está en ejecución.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker create --name mi_contenedor nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Ejecución (Start/Run)</strong>
.El contenedor pasa a estar en ejecución, ejecutando el proceso principal definido en la imagen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker start mi_contenedor
# O bien, crear y ejecutar en un solo paso:
docker run -d --name mi_contenedor nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Pausa y reanudación</strong>
.Puedes pausar temporalmente todos los procesos de un contenedor y luego reanudarlos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker pause mi_contenedor
docker unpause mi_contenedor</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Detención</strong>
.El contenedor se detiene, finalizando el proceso principal, pero su estado y sistema de archivos persisten.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker stop mi_contenedor</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Reinicio</strong>
.Puedes reiniciar un contenedor detenido.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker restart mi_contenedor</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Eliminación</strong>
.El contenedor se elimina del sistema. Sus datos efímeros se pierden, pero los volúmenes persistentes permanecen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker rm mi_contenedor</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_diagrama_del_ciclo_de_vida">Diagrama del ciclo de vida</h4>
<div class="literalblock">
<div class="content">
<pre>@startuml
[*] --&gt; Creado
Creado --&gt; EnEjecucion : start/run
EnEjecucion --&gt; Pausado : pause
Pausado --&gt; EnEjecucion : unpause
EnEjecucion --&gt; Detenido : stop
Detenido --&gt; EnEjecucion : start
Detenido --&gt; Eliminado : rm
EnEjecucion --&gt; Eliminado : rm -f
@enduml</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico">Ejemplo práctico</h4>
<div class="listingblock">
<div class="title">A continuación, se muestra un ejemplo práctico de cómo gestionar el ciclo de vida de un contenedor Docker. En este caso, crearemos un contenedor a partir de la imagen <code>nginx</code>, lo iniciaremos, lo pausaremos y reanudaremos, y finalmente lo detendremos y eliminaremos.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Crear un contenedor (sin ejecutarlo)
docker create --name demo nginx

# Iniciar el contenedor
docker start demo

# Pausar y reanudar
docker pause demo
docker unpause demo

# Detener el contenedor
docker stop demo

# Reiniciar el contenedor
docker restart demo

# Eliminar el contenedor
docker rm demo</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_estados_de_un_contenedor">Estados de un contenedor</h4>
<div class="ulist">
<ul>
<li>
<p><strong>created</strong>: El contenedor ha sido creado pero no está en ejecución.</p>
</li>
<li>
<p><strong>running</strong>: El contenedor está ejecutando su proceso principal.</p>
</li>
<li>
<p><strong>paused</strong>: Los procesos del contenedor están detenidos temporalmente.</p>
</li>
<li>
<p><strong>stopped/exited</strong>: El proceso principal terminó y el contenedor está detenido.</p>
</li>
<li>
<p><strong>removed</strong>: El contenedor ha sido eliminado del sistema.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Puedes consultar el estado de todos los contenedores con:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker ps -a</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comandos_esenciales_run_ps_pull_exec_logs_etc">Comandos esenciales (run, ps, pull, exec, logs, etc.)</h3>
<div class="paragraph">
<p>En este apartado se explican de forma didáctica y detallada los comandos fundamentales de Docker para la gestión diaria de imágenes y contenedores. Cada comando se acompaña de ejemplos prácticos, explicaciones de sus opciones más relevantes y buenas prácticas de uso.</p>
</div>
<div class="sect3">
<h4 id="_docker_run">docker run</h4>
<div class="paragraph">
<p>El comando <code>docker run</code> es el punto de partida para trabajar con contenedores. Permite crear e iniciar un contenedor a partir de una imagen.</p>
</div>
<div class="paragraph">
<p><strong>Sintaxis básica:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run [opciones] imagen [comando]</code></pre>
</div>
</div>
<div class="ulist">
<div class="title"><strong>Opciones más utilizadas:</strong></div>
<ul>
<li>
<p><code>-d</code>: Ejecuta el contenedor en segundo plano (detached).</p>
</li>
<li>
<p><code>--name nombre</code>: Asigna un nombre personalizado al contenedor.</p>
</li>
<li>
<p><code>-p host:contenedor</code>: Mapea puertos del host al contenedor.</p>
</li>
<li>
<p><code>-v host:contenedor</code>: Monta volúmenes o directorios.</p>
</li>
<li>
<p><code>-e VAR=valor</code>: Define variables de entorno.</p>
</li>
<li>
<p><code>--rm</code>: Elimina el contenedor al detenerse.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Ejemplo:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name miweb -p 8080:80 nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este comando descarga la imagen de nginx (si no está presente), crea un contenedor llamado <code>miweb</code>, mapea el puerto 8080 del host al 80 del contenedor y lo ejecuta en segundo plano.</p>
</div>
</div>
<div class="sect3">
<h4 id="_docker_ps">docker ps</h4>
<div class="paragraph">
<p>Permite listar los contenedores en ejecución.</p>
</div>
<div class="paragraph">
<p><strong>Comando básico:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker ps</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Para ver todos los contenedores (incluidos los detenidos):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker ps -a</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opciones útiles:</strong>
- <code>-q</code>: Muestra solo los IDs de los contenedores.
- <code>--format</code>: Personaliza la salida.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_docker_pull">docker pull</h4>
<div class="paragraph">
<p>Descarga una imagen desde un registro (por defecto, Docker Hub).</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker pull ubuntu:22.04
docker pull nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto asegura que tienes la última versión de la imagen antes de crear un contenedor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_docker_exec">docker exec</h4>
<div class="paragraph">
<p>Permite ejecutar comandos dentro de un contenedor en ejecución, ideal para tareas de administración o depuración.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo para abrir una terminal interactiva:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec -it miweb bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el contenedor no tiene bash, puedes usar <code>sh</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec -it miweb sh</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Ejemplo para ejecutar un comando puntual:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec miweb ls /usr/share/nginx/html</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_docker_logs">docker logs</h4>
<div class="paragraph">
<p>Muestra los logs (salida estándar y de error) de un contenedor, útil para depuración y monitoreo.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker logs miweb</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opciones útiles:</strong>
- <code>-f</code>: Sigue los logs en tiempo real (modo "follow").
- <code>--tail N</code>: Muestra solo las últimas N líneas.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker logs -f --tail 50 miweb</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_otros_comandos_esenciales">Otros comandos esenciales</h4>
<div class="listingblock">
<div class="title"><strong>docker stop</strong>: Detiene un contenedor en ejecución.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker stop miweb</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>docker start</strong>: Inicia un contenedor detenido.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker start miweb</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>docker rm</strong>: Elimina un contenedor detenido.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker rm miweb</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>docker rmi</strong>: Elimina una imagen (debe estar sin uso).</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker rmi nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>docker images</strong>: Lista las imágenes locales.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker images</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>docker inspect</strong>: Muestra información detallada de un contenedor o imagen.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker inspect miweb</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_práctico">Resumen práctico</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Comando</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker run</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crea y ejecuta un contenedor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker ps</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lista contenedores en ejecución</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker ps -a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lista todos los contenedores</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker pull</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descarga una imagen</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker exec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ejecuta comandos en un contenedor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker logs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Muestra los logs de un contenedor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker stop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Detiene un contenedor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker start</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inicia un contenedor detenido</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker rm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elimina un contenedor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker rmi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elimina una imagen</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker images</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lista imágenes locales</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docker inspect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inspecciona detalles de un contenedor/imagen</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Asigna nombres descriptivos a tus contenedores.</p>
</li>
<li>
<p>Usa <code>docker ps -a</code> para limpiar contenedores detenidos.</p>
</li>
<li>
<p>Elimina imágenes y contenedores que no uses para ahorrar espacio.</p>
</li>
<li>
<p>Utiliza logs y exec para depurar tus aplicaciones dentro de los contenedores.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_ciclo_completo">Ejemplo de ciclo completo</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Descargar una imagen
docker pull nginx

# Crear y ejecutar un contenedor
docker run -d --name webtest -p 8080:80 nginx

# Ver contenedores en ejecución
docker ps

# Acceder al contenedor
docker exec -it webtest bash

# Ver logs
docker logs webtest

# Detener y eliminar el contenedor
docker stop webtest
docker rm webtest</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_y_solución_de_problemas">Depuración y solución de problemas</h3>
<div class="paragraph">
<p>La depuración y solución de problemas en Docker es fundamental para mantener entornos estables y aplicaciones funcionales. A continuación se presentan técnicas, comandos y buenas prácticas para identificar y resolver incidencias en contenedores, imágenes y el propio entorno Docker.</p>
</div>
<div class="sect3">
<h4 id="_inspección_de_contenedores_y_logs">Inspección de contenedores y logs</h4>
<div class="sect4">
<h5 id="_ver_logs_de_un_contenedor_2">Ver logs de un contenedor</h5>
<div class="paragraph">
<p>El comando <code>docker logs</code> permite visualizar la salida estándar y de error de un contenedor, lo que es esencial para detectar fallos en la aplicación.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker logs &lt;nombre_o_id_contenedor&gt;
docker logs -f &lt;nombre_o_id_contenedor&gt;      # Sigue los logs en tiempo real
docker logs --tail 100 &lt;nombre_o_id_contenedor&gt;  # Últimas 100 líneas</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_inspeccionar_detalles_de_un_contenedor">Inspeccionar detalles de un contenedor</h5>
<div class="paragraph">
<p><code>docker inspect</code> muestra información detallada sobre la configuración, red, volúmenes y estado de un contenedor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker inspect &lt;nombre_o_id_contenedor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes filtrar información específica usando <code>--format</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker inspect --format='{{.State.Status}}' &lt;nombre_o_id_contenedor&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_acceso_interactivo_y_ejecución_de_comandos">Acceso interactivo y ejecución de comandos</h4>
<div class="paragraph">
<p>Si necesitas investigar el estado interno de un contenedor, puedes acceder a su shell:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec -it &lt;nombre_o_id_contenedor&gt; bash
# Si bash no está disponible:
docker exec -it &lt;nombre_o_id_contenedor&gt; sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto permite revisar archivos de configuración, logs internos, procesos en ejecución, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_monitorización_de_recursos">Monitorización de recursos</h4>
<div class="paragraph">
<p>Docker ofrece herramientas para monitorizar el uso de CPU, memoria y red de los contenedores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker stats</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto ayuda a identificar cuellos de botella o fugas de memoria.</p>
</div>
</div>
<div class="sect3">
<h4 id="_diagnóstico_de_redes_y_conectividad">Diagnóstico de redes y conectividad</h4>
<div class="sect4">
<h5 id="_listar_redes_y_comprobar_conexiones">Listar redes y comprobar conexiones</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network ls
docker network inspect &lt;nombre_red&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_probar_conectividad_entre_contenedores">Probar conectividad entre contenedores</h5>
<div class="paragraph">
<p>Puedes usar utilidades como <code>ping</code> o <code>curl</code> dentro de los contenedores para verificar la comunicación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec -it &lt;contenedor1&gt; ping &lt;contenedor2&gt;
docker exec -it &lt;contenedor1&gt; curl http://&lt;contenedor2&gt;:&lt;puerto&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_solución_de_problemas_comunes">Solución de problemas comunes</h4>
<div class="sect4">
<h5 id="_el_contenedor_se_detiene_inmediatamente">El contenedor se detiene inmediatamente</h5>
<div class="ulist">
<ul>
<li>
<p>Revisa los logs (<code>docker logs</code>).</p>
</li>
<li>
<p>Verifica el comando de inicio en el Dockerfile o la configuración.</p>
</li>
<li>
<p>Comprueba si faltan variables de entorno o archivos de configuración.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_problemas_de_permisos">Problemas de permisos</h5>
<div class="ulist">
<ul>
<li>
<p>Asegúrate de que los volúmenes montados tengan los permisos adecuados.</p>
</li>
<li>
<p>Usa <code>docker exec</code> para inspeccionar permisos dentro del contenedor.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_problemas_de_red">Problemas de red</h5>
<div class="ulist">
<ul>
<li>
<p>Verifica que los puertos estén correctamente mapeados (<code>-p</code>).</p>
</li>
<li>
<p>Comprueba las reglas de firewall del host.</p>
</li>
<li>
<p>Usa <code>docker network inspect</code> para ver la configuración de red.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_problemas_con_imágenes">Problemas con imágenes</h5>
<div class="ulist">
<ul>
<li>
<p>Si una imagen no se descarga, verifica la conexión a Internet y el nombre de la imagen.</p>
</li>
<li>
<p>Usa <code>docker pull</code> para forzar la descarga.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Si hay problemas de espacio, limpia imágenes y contenedores no usados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker system prune -a</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_herramientas_avanzadas_de_depuración">Herramientas avanzadas de depuración</h4>
<div class="listingblock">
<div class="title"><strong>docker events</strong>: Muestra eventos en tiempo real del daemon Docker.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker events</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>docker top</strong>: Muestra los procesos activos dentro de un contenedor.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker top &lt;nombre_o_id_contenedor&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>docker diff</strong>: Muestra los cambios en el sistema de archivos de un contenedor respecto a su imagen base.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker diff &lt;nombre_o_id_contenedor&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_de_depuración">Ejemplo práctico de depuración</h4>
<div class="listingblock">
<div class="title">Supón que tu contenedor web no responde:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># 1. Verifica si está en ejecución
docker ps

# 2. Consulta los logs
docker logs webserver

# 3. Accede al contenedor para investigar
docker exec -it webserver bash

# 4. Comprueba el uso de recursos
docker stats

# 5. Revisa la configuración de red
docker inspect webserver</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_para_evitar_y_resolver_problemas">Buenas prácticas para evitar y resolver problemas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa imágenes oficiales y mantenidas.</p>
</li>
<li>
<p>Mantén Docker y tus imágenes actualizadas.</p>
</li>
<li>
<p>Elimina recursos no utilizados regularmente (<code>docker system prune</code>).</p>
</li>
<li>
<p>Documenta la configuración y dependencias de tus contenedores.</p>
</li>
<li>
<p>Automatiza pruebas y despliegues para detectar errores temprano.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_recursos_adicionales">Recursos adicionales</h4>
<div class="ulist">
<ul>
<li>
<p>Documentación oficial: <a href="https://docs.docker.com/config/containers/troubleshoot/" class="bare">https://docs.docker.com/config/containers/troubleshoot/</a></p>
</li>
<li>
<p>Comando de ayuda: <code>docker &lt;comando&gt; --help</code></p>
</li>
<li>
<p>Comunidad y foros: <a href="https://forums.docker.com/" class="bare">https://forums.docker.com/</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creación_de_imágenes_docker">Creación de Imágenes Docker</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En este enderás a crear tus propias imágenes Docker de forma didáctica y estructurada. Se explican los conceptos clave, las instrucciones más importantes del Dockerfile, buenas prácticas y ejemplos prácticos para que puedas construir imágenes eficientes y seguras.</p>
</div>
<div class="sect2">
<h3 id="_introducción_a_dockerfile">Introducción a Dockerfile</h3>
<div class="paragraph">
<p>Un Dockerfile es un archivo de texto que contiene una serie de instrucciones que Docker utiliza para construir una imagen personalizada. Cada instrucción en el Dockerfile crea una nueva capa en la imagen, permitiendo la reutilización y eficiencia en el almacenamiento y la transferencia.</p>
</div>
<div class="sect3">
<h4 id="_por_qué_usar_dockerfile">¿Por qué usar Dockerfile?</h4>
<div class="ulist">
<ul>
<li>
<p>Permite automatizar la creación de imágenes, asegurando entornos reproducibles.</p>
</li>
<li>
<p>Facilita la integración continua y el despliegue automático.</p>
</li>
<li>
<p>Mejora la portabilidad y la colaboración entre equipos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_estructura_básica_de_un_dockerfile">Estructura básica de un Dockerfile</h4>
<div class="ulist">
<div class="title">Un Dockerfile se compone de instrucciones escritas en mayúsculas, cada una con un propósito específico. Las más comunes son:</div>
<ul>
<li>
<p><code>FROM</code>: Define la imagen base.</p>
</li>
<li>
<p><code>RUN</code>: Ejecuta comandos en la imagen durante el build.</p>
</li>
<li>
<p><code>COPY</code> y <code>ADD</code>: Copian archivos/directorios al sistema de archivos de la imagen.</p>
</li>
<li>
<p><code>WORKDIR</code>: Establece el directorio de trabajo.</p>
</li>
<li>
<p><code>ENV</code>: Define variables de entorno.</p>
</li>
<li>
<p><code>EXPOSE</code>: Documenta el puerto que usará la aplicación.</p>
</li>
<li>
<p><code>CMD</code> y <code>ENTRYPOINT</code>: Definen el comando que se ejecutará al iniciar el contenedor.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_sencillo_de_dockerfile">Ejemplo sencillo de Dockerfile</h4>
<div class="listingblock">
<div class="title">A continuación, un ejemplo de Dockerfile para una aplicación Python:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_proceso_de_construcción_de_una_imagen">Proceso de construcción de una imagen</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Crea un archivo llamado <code>Dockerfile</code> en el directorio raíz de tu proyecto.</p>
</li>
<li>
<p>Escribe las instrucciones necesarias según tu aplicación.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Construye la imagen con el comando:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker build -t miapp:1.0 .</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejecuta un contenedor basado en tu imagen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name miapp -p 5000:5000 miapp:1.0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_iniciales">Buenas prácticas iniciales</h4>
<div class="ulist">
<ul>
<li>
<p>Mantén el Dockerfile simple y ordenado.</p>
</li>
<li>
<p>Usa imágenes base ligeras (como <code>alpine</code> o <code>slim</code>) para reducir el tamaño.</p>
</li>
<li>
<p>Agrupa las instrucciones <code>RUN</code> para minimizar el número de capas.</p>
</li>
<li>
<p>Usa <code>COPY</code> en lugar de <code>ADD</code> a menos que necesites la funcionalidad adicional de <code>ADD</code>.</p>
</li>
<li>
<p>Usa <code>WORKDIR</code> para establecer el directorio de trabajo en lugar de usar rutas absolutas.</p>
</li>
<li>
<p>Define variables de entorno con <code>ENV</code> para facilitar la configuración.</p>
</li>
<li>
<p>Usa <code>EXPOSE</code> para documentar los puertos que tu aplicación usará, aunque no es obligatorio.</p>
</li>
<li>
<p>Usa <code>CMD</code> para definir el comando por defecto, pero permite que se sobrescriba al ejecutar el contenedor.</p>
</li>
<li>
<p>Usa <code>ENTRYPOINT</code> para definir el comando principal que no debe ser sobrescrito.</p>
</li>
<li>
<p>Usa <code>--no-cache-dir</code> al instalar dependencias para evitar almacenar caché innecesario.</p>
</li>
<li>
<p>Mantén el Dockerfile en el control de versiones junto con tu código fuente.</p>
</li>
<li>
<p>Usa etiquetas (<code>tags</code>) para versionar tus imágenes y facilitar la gestión de cambios.</p>
</li>
<li>
<p>No incluyas archivos sensibles o secretos en la imagen.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instrucciones_básicas">Instrucciones básicas</h3>
<div class="paragraph">
<p>Las instrucciones del Dockerfile definen cómo se construye una imagen Docker. Cada instrucción genera una nueva capa, por lo que su uso eficiente es clave para crear imágenes ligeras, seguras y fáciles de mantener. A continuación se explican las instrucciones más importantes, su sintaxis y ejemplos prácticos.</p>
</div>
<div class="sect3">
<h4 id="_from">FROM</h4>
<div class="paragraph">
<p>Especifica la imagen base sobre la que se construirá la nueva imagen. Es la primera instrucción obligatoria en cualquier Dockerfile.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">FROM ubuntu:22.04</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes usar imágenes oficiales o personalizadas. También puedes construir imágenes multietapa usando varias instrucciones FROM.</p>
</div>
</div>
<div class="sect3">
<h4 id="_run">RUN</h4>
<div class="paragraph">
<p>Ejecuta comandos en la imagen durante el proceso de construcción. Es útil para instalar paquetes, actualizar el sistema o preparar el entorno.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">RUN apt-get update &amp;&amp; apt-get install -y nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para reducir el número de capas, agrupa varios comandos en una sola instrucción RUN usando <code>&amp;&amp;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_copy">COPY</h4>
<div class="paragraph">
<p>Copia archivos o directorios desde el contexto de construcción (tu máquina) al sistema de archivos de la imagen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">COPY index.html /usr/share/nginx/html/
COPY src/ /app/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es preferible a ADD cuando solo necesitas copiar archivos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_add">ADD</h4>
<div class="paragraph">
<p>Similar a COPY, pero con funcionalidades adicionales:
- Permite descomprimir archivos <code>.tar</code> automáticamente.
- Puede descargar archivos desde URLs (no recomendado por seguridad y reproducibilidad).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">ADD archivo.tar.gz /app/
ADD https://ejemplo.com/archivo.txt /tmp/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usa COPY salvo que necesites estas características extra.</p>
</div>
</div>
<div class="sect3">
<h4 id="_workdir">WORKDIR</h4>
<div class="paragraph">
<p>Establece el directorio de trabajo para las siguientes instrucciones RUN, CMD, ENTRYPOINT, COPY y ADD.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">WORKDIR /app</code></pre>
</div>
</div>
<div class="paragraph">
<p>Evita el uso de rutas absolutas repetidas y mejora la legibilidad.</p>
</div>
</div>
<div class="sect3">
<h4 id="_env">ENV</h4>
<div class="paragraph">
<p>Define variables de entorno dentro de la imagen, accesibles por la aplicación y durante el build.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">ENV PORT=8080
ENV NODE_ENV=production</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_expose">EXPOSE</h4>
<div class="paragraph">
<p>Documenta el puerto que la aplicación usará. No publica el puerto, solo lo deja registrado en la imagen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">EXPOSE 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cmd">CMD</h4>
<div class="paragraph">
<p>Define el comando por defecto que se ejecutará al iniciar el contenedor. Puede ser sobrescrito al ejecutar <code>docker run</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">CMD ["nginx", "-g", "daemon off;"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Solo puede haber una instrucción CMD; si hay varias, se usará la última.</p>
</div>
</div>
<div class="sect3">
<h4 id="_entrypoint">ENTRYPOINT</h4>
<div class="paragraph">
<p>Establece el proceso principal del contenedor. A diferencia de CMD, no suele ser sobrescrito por <code>docker run</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">ENTRYPOINT ["python", "app.py"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes combinar ENTRYPOINT y CMD para permitir argumentos por defecto y personalizados.</p>
</div>
</div>
<div class="sect3">
<h4 id="_user">USER</h4>
<div class="paragraph">
<p>Define el usuario con el que se ejecutarán las siguientes instrucciones y el proceso principal del contenedor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">USER appuser</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_label">LABEL</h4>
<div class="paragraph">
<p>Permite añadir metadatos a la imagen, como el autor, versión o descripción.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">LABEL maintainer="tuemail@ejemplo.com"
LABEL version="1.0"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_completo_de_dockerfile">Ejemplo completo de Dockerfile</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">FROM node:20-alpine
WORKDIR /app
COPY package.json .
RUN npm install --production
COPY . .
ENV NODE_ENV=production
EXPOSE 3000
USER node
CMD ["node", "index.js"]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_2">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p>Usa FROM para definir la base.</p>
</li>
<li>
<p>RUN para instalar y configurar.</p>
</li>
<li>
<p>COPY/ADD para añadir archivos.</p>
</li>
<li>
<p>WORKDIR y ENV para configurar el entorno.</p>
</li>
<li>
<p>EXPOSE, CMD y ENTRYPOINT para definir el comportamiento del contenedor.</p>
</li>
<li>
<p>USER y LABEL para seguridad y metadatos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buenas_prácticas_en_la_creación_de_imágenes">Buenas prácticas en la creación de imágenes</h3>
<div class="paragraph">
<p>Aplicar buenas prácticas al crear imágenes Docker es fundamental para obtener imágenes más seguras, ligeras, eficientes y fáciles de mantener. A continuación se presentan recomendaciones didácticas, estructuradas y acompañadas de ejemplos.</p>
</div>
<div class="sect3">
<h4 id="_usa_imágenes_base_oficiales_y_ligeras">Usa imágenes base oficiales y ligeras</h4>
<div class="paragraph">
<p>Prefiere imágenes oficiales y versiones "slim" o "alpine" cuando sea posible, ya que ocupan menos espacio y reducen la superficie de ataque.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de imagen base oficial y ligera:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">FROM python:3.11-slim
# o
FROM node:20-alpine</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_minimiza_el_número_de_capas">Minimiza el número de capas</h4>
<div class="paragraph">
<p>Cada instrucción en el Dockerfile crea una capa. Agrupa comandos relacionados en una sola instrucción RUN usando <code>&amp;&amp;</code> para reducir el número de capas.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de agrupación de comandos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">RUN apt-get update &amp;&amp; \
    apt-get install -y nginx curl &amp;&amp; \
    rm -rf /var/lib/apt/lists/*</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_elimina_archivos_temporales_y_cachés">Elimina archivos temporales y cachés</h4>
<div class="paragraph">
<p>Limpia archivos temporales y cachés de instalación para reducir el tamaño de la imagen.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de limpieza de caché de pip:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">RUN pip install --no-cache-dir -r requirements.txt</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_usa_copy_en_lugar_de_add">Usa COPY en lugar de ADD</h4>
<div class="paragraph">
<p>Utiliza <code>COPY</code> para copiar archivos locales y reserva <code>ADD</code> solo para casos donde necesites descomprimir archivos <code>.tar</code> o descargar desde una URL.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de COPY:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">COPY . /app/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_define_variables_de_entorno_y_puertos_explícitamente">Define variables de entorno y puertos explícitamente</h4>
<div class="paragraph">
<p>Utiliza <code>ENV</code> y <code>EXPOSE</code> para documentar la configuración y los puertos que usará tu aplicación.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de definición de variables de entorno y puertos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">ENV NODE_ENV=production
EXPOSE 3000</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_no_incluyas_secretos_ni_archivos_sensibles">No incluyas secretos ni archivos sensibles</h4>
<div class="paragraph">
<p>Nunca añadas contraseñas, claves privadas o archivos sensibles en la imagen. Usa variables de entorno o sistemas de gestión de secretos externos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_usa_usuarios_no_privilegiados">Usa usuarios no privilegiados</h4>
<div class="paragraph">
<p>Evita ejecutar aplicaciones como root. Crea y usa un usuario específico para tu aplicación.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de creación de un usuario no privilegiado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">RUN useradd -m appuser
USER appuser</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mantén_el_dockerfile_limpio_y_ordenado">Mantén el Dockerfile limpio y ordenado</h4>
<div class="paragraph">
<p>Comenta las secciones importantes y elimina instrucciones innecesarias. Mantén el archivo bajo control de versiones junto con tu código fuente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_versiona_tus_imágenes">Versiona tus imágenes</h4>
<div class="paragraph">
<p>Utiliza etiquetas (<code>tags</code>) para identificar versiones específicas de tus imágenes y facilitar la gestión de despliegues.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de etiquetado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker build -t miapp:1.0 .</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_usa_archivos_dockerignore">Usa archivos .dockerignore</h4>
<div class="paragraph">
<p>Incluye un archivo <code>.dockerignore</code> para excluir archivos y carpetas innecesarias del contexto de build, como logs, archivos temporales y dependencias locales.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de .dockerignore:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">*.pyc
__pycache__/
node_modules/
.git/
Dockerfile
.dockerignore</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_11_actualiza_y_revisa_tus_imágenes_regularmente">11. Actualiza y revisa tus imágenes regularmente</h4>
<div class="paragraph">
<p>Mantén tus imágenes y dependencias actualizadas para evitar vulnerabilidades de seguridad.</p>
</div>
</div>
<div class="sect3">
<h4 id="_12_ejemplo_de_dockerfile_siguiendo_buenas_prácticas">12. Ejemplo de Dockerfile siguiendo buenas prácticas</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">FROM node:20-alpine
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
USER node
CMD ["node", "index.js"]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optimización_de_imágenes_tamaño_y_capas">Optimización de imágenes: tamaño y capas</h3>
<div class="paragraph">
<p>Optimizar el tamaño y la estructura de capas de una imagen Docker es esencial para mejorar la eficiencia, reducir tiempos de descarga y despliegue, y minimizar vulnerabilidades. A continuación se presentan estrategias didácticas y ejemplos prácticos para lograr imágenes más ligeras y eficientes.</p>
</div>
<div class="sect3">
<h4 id="_usa_imágenes_base_minimalistas">Usa imágenes base minimalistas</h4>
<div class="listingblock">
<div class="title">Prioriza imágenes como <code>alpine</code> o versiones <code>slim</code> de los lenguajes y sistemas operativos.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">FROM python:3.11-alpine
# o
FROM node:20-slim</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_agrupa_comandos_en_una_sola_instrucción_run">Agrupa comandos en una sola instrucción RUN</h4>
<div class="paragraph">
<p>Cada instrucción RUN crea una capa. Agrupa comandos relacionados usando <code>&amp;&amp;</code> para reducir el número de capas y limpiar archivos temporales en el mismo paso.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de agrupación de comandos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">RUN apt-get update &amp;&amp; \
    apt-get install -y build-essential curl &amp;&amp; \
    rm -rf /var/lib/apt/lists/*</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_elimina_archivos_innecesarios_y_cachés">Elimina archivos innecesarios y cachés</h4>
<div class="paragraph">
<p>Borra archivos temporales, cachés de paquetes y dependencias de desarrollo tras la instalación.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de limpieza de caché de pip:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">RUN pip install --no-cache-dir -r requirements.txt</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_usa_archivos_dockerignore_2">Usa archivos .dockerignore</h4>
<div class="paragraph">
<p>Incluye un archivo <code>.dockerignore</code> para evitar copiar archivos y carpetas innecesarias al contexto de build, como dependencias locales, archivos temporales y carpetas de control de versiones.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de .dockerignore:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">*.log
node_modules/
.git/
tests/
Dockerfile
.dockerignore</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_copia_solo_lo_necesario">Copia solo lo necesario</h4>
<div class="paragraph">
<p>Evita copiar todo el proyecto si solo necesitas algunos archivos para construir la imagen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">COPY src/ /app/src/
COPY package.json package-lock.json /app/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multi_stage_builds_construcción_multietapa">Multi-stage builds (construcción multietapa)</h4>
<div class="paragraph">
<p>Utiliza varias etapas en el Dockerfile para compilar o construir artefactos en una imagen temporal y copiar solo el resultado final a la imagen de producción. Esto reduce drásticamente el tamaño de la imagen final.</p>
</div>
<div class="listingblock">
<div class="title">Las imágenes multietapa permiten separar el proceso de construcción del de ejecución, eliminando dependencias y herramientas de desarrollo innecesarias en la imagen final.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile"># Etapa de build
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

# Etapa de producción
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_elimina_herramientas_de_desarrollo_en_producción">Elimina herramientas de desarrollo en producción</h4>
<div class="paragraph">
<p>Instala compiladores y herramientas solo en etapas de build, no en la imagen final.</p>
</div>
</div>
<div class="sect3">
<h4 id="_usa_imágenes_oficiales_y_mantenidas">Usa imágenes oficiales y mantenidas</h4>
<div class="paragraph">
<p>Las imágenes oficiales suelen estar optimizadas y actualizadas, lo que ayuda a reducir el tamaño y mejorar la seguridad.</p>
</div>
</div>
<div class="sect3">
<h4 id="_analiza_y_revisa_el_tamaño_de_tus_imágenes">Analiza y revisa el tamaño de tus imágenes</h4>
<div class="listingblock">
<div class="title">Utiliza comandos como <code>docker images</code> y herramientas como <code>dive</code> para inspeccionar el tamaño de cada capa y detectar archivos innecesarios.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker images
dive miapp:latest</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_dockerfile_optimizado">Ejemplo de Dockerfile optimizado</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile"># Etapa de build
FROM golang:1.22-alpine AS builder
WORKDIR /src
COPY . .
RUN go build -o app

# Imagen final mínima
FROM alpine:3.19
WORKDIR /app
COPY --from=builder /src/app .
EXPOSE 8080
CMD ["./app"]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_de_recomendaciones">Resumen de recomendaciones</h4>
<div class="ulist">
<ul>
<li>
<p>Usa imágenes base ligeras.</p>
</li>
<li>
<p>Agrupa comandos y limpia archivos temporales en la misma capa.</p>
</li>
<li>
<p>Utiliza <code>.dockerignore</code> para reducir el contexto de build.</p>
</li>
<li>
<p>Aplica multi-stage builds para separar dependencias de desarrollo y producción.</p>
</li>
<li>
<p>Analiza regularmente el tamaño y las capas de tus imágenes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_imágenes_multietapa">Imágenes multietapa</h3>
<div class="paragraph">
<p>Las imágenes multietapa (multi-stage builds) son una técnica avanzada de Docker que permite crear imágenes más pequeñas, seguras y eficientes. Consiste en definir varias etapas en un mismo Dockerfile, utilizando diferentes imágenes base y copiando solo los artefactos necesarios a la imagen final. Esto es especialmente útil para aplicaciones que requieren compilación o construcción previa, ya que evita incluir herramientas y dependencias de desarrollo en la imagen de producción.</p>
</div>
<div class="sect3">
<h4 id="_ventajas_de_las_imágenes_multietapa">Ventajas de las imágenes multietapa</h4>
<div class="ulist">
<ul>
<li>
<p>Reducción significativa del tamaño de la imagen final.</p>
</li>
<li>
<p>Mayor seguridad: solo se incluyen los archivos y binarios necesarios para ejecutar la aplicación.</p>
</li>
<li>
<p>Facilita la gestión de dependencias y la separación entre entornos de build y producción.</p>
</li>
<li>
<p>Permite reutilizar etapas para diferentes propósitos (test, build, producción).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_sintaxis_y_funcionamiento">Sintaxis y funcionamiento</h4>
<div class="paragraph">
<p>Cada etapa comienza con una instrucción <code>FROM</code>. Puedes asignar un alias a cada etapa usando <code>AS nombre</code>, lo que facilita copiar archivos entre etapas.</p>
</div>
<div class="listingblock">
<div class="title">Las etapas se definen de la siguiente manera:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile"># Etapa de compilación
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

# Etapa de producción
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo:
- La primera etapa (<code>build</code>) instala dependencias y construye la aplicación.
- La segunda etapa parte de una imagen mínima (<code>nginx:alpine</code>) y solo copia los archivos generados en la etapa anterior.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_aplicación_go">Ejemplo práctico: aplicación Go</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile"># Etapa de build
FROM golang:1.22-alpine AS builder
WORKDIR /src
COPY . .
RUN go build -o app

# Imagen final mínima
FROM alpine:3.19
WORKDIR /app
COPY --from=builder /src/app .
EXPOSE 8080
CMD ["./app"]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multi_stage_para_eliminar_dependencias_de_desarrollo">Multi-stage para eliminar dependencias de desarrollo</h4>
<div class="listingblock">
<div class="title">Puedes usar tantas etapas como necesites, por ejemplo, para ejecutar tests antes de construir la imagen final:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile"># Etapa de test
FROM node:20-alpine AS test
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm test

# Etapa de build
FROM node:20-alpine AS build
WORKDIR /app
COPY --from=test /app .
RUN npm run build

# Etapa de producción
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_con_imágenes_multietapa">Buenas prácticas con imágenes multietapa</h4>
<div class="ulist">
<ul>
<li>
<p>Utiliza nombres descriptivos para las etapas (<code>AS build</code>, <code>AS test</code>, <code>AS prod</code>).</p>
</li>
<li>
<p>Copia solo los artefactos necesarios a la imagen final.</p>
</li>
<li>
<p>Elimina archivos temporales y dependencias de desarrollo en las etapas intermedias.</p>
</li>
<li>
<p>Usa imágenes base ligeras en la etapa final.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_publicación_de_imágenes_en_docker_hub">Publicación de imágenes en Docker Hub</h3>
<div class="paragraph">
<p>Publicar imágenes en Docker Hub te permite compartir tus aplicaciones y entornos con otros usuarios o equipos, facilitando el despliegue y la colaboración. Docker Hub es el registro público más popular, aunque también existen registros privados y alternativos.</p>
</div>
<div class="sect3">
<h4 id="_crear_una_cuenta_en_docker_hub">Crear una cuenta en Docker Hub</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Accede a <a href="https://hub.docker.com/" class="bare">https://hub.docker.com/</a> y regístrate gratuitamente.</p>
</li>
<li>
<p>Elige un nombre de usuario único; este será el prefijo de tus imágenes (por ejemplo, <code>usuario/miimagen</code>).</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_iniciar_sesión_desde_la_terminal">Iniciar sesión desde la terminal</h4>
<div class="listingblock">
<div class="title">Antes de publicar, debes autenticarte en Docker Hub desde tu terminal:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker login</code></pre>
</div>
</div>
<div class="paragraph">
<p>Introduce tu usuario y contraseña cuando se solicite.</p>
</div>
</div>
<div class="sect3">
<h4 id="_etiquetar_la_imagen_para_docker_hub">Etiquetar la imagen para Docker Hub</h4>
<div class="listingblock">
<div class="title">Las imágenes deben tener el formato <code>usuario/imagen:tag</code>. Puedes etiquetar una imagen existente con:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker tag miapp:1.0 usuario/miapp:1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Reemplaza <code>usuario</code> por tu nombre de usuario de Docker Hub.</p>
</div>
</div>
<div class="sect3">
<h4 id="_subir_la_imagen_al_registro">Subir la imagen al registro</h4>
<div class="listingblock">
<div class="title">Utiliza el comando <code>push</code> para publicar la imagen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker push usuario/miapp:1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Docker subirá todas las capas de la imagen a tu repositorio en Docker Hub.</p>
</div>
</div>
<div class="sect3">
<h4 id="_verificar_la_publicación">Verificar la publicación</h4>
<div class="paragraph">
<p>Accede a tu cuenta en <a href="https://hub.docker.com/" class="bare">https://hub.docker.com/</a> y verifica que la imagen aparece en tu repositorio. Puedes ver detalles como el número de descargas, etiquetas y capas.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_redes_en_docker">Redes en Docker</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En este enderás cómo Docker gestiona las redes y la comunicación entre contenedores, así como las mejores prácticas para exponer servicios y crear redes personalizadas. El dominio de las redes en Docker es esencial para diseñar arquitecturas seguras, escalables y eficientes.</p>
</div>
<div class="sect2">
<h3 id="_tipos_de_redes_en_docker">Tipos de redes en Docker</h3>
<div class="paragraph">
<p>Docker proporciona varios tipos de redes para conectar contenedores entre sí y con el exterior.
.Cada tipo de red tiene características y casos de uso específicos:
- <strong>bridge</strong>: Red por defecto para contenedores en un solo host.
- <strong>host</strong>: Comparte la red del host, sin aislamiento.
- <strong>none</strong>: Sin conectividad de red.
- <strong>overlay</strong>: Permite la comunicación entre contenedores en diferentes hosts (ideal para clústeres).
- <strong>macvlan</strong>: Asigna una dirección MAC y IP propia al contenedor, integrándolo en la red física del host.</p>
</div>
<div class="sect3">
<h4 id="_bridge_puente">bridge (puente)</h4>
<div class="paragraph">
<p>Es la red por defecto para contenedores en un solo host. Permite la comunicación entre contenedores conectados a la misma red bridge, pero aísla los contenedores de otros hosts y redes externas (salvo que se expongan puertos).</p>
</div>
<div class="listingblock">
<div class="title">Crear una red bridge personalizada:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create mi_red_bridge</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Conectar un contenedor a la red bridge:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name app1 --network mi_red_bridge nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_host">host</h4>
<div class="paragraph">
<p>El contenedor comparte la pila de red del host, sin aislamiento de red. Es útil para aplicaciones que requieren acceso directo a la red del host, pero reduce el aislamiento.</p>
</div>
<div class="listingblock">
<div class="title">Crear un contenedor usando la red del host:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run --network host nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_none">none</h4>
<div class="paragraph">
<p>El contenedor no tiene acceso a ninguna red. Solo es útil para casos de aislamiento extremo o pruebas.</p>
</div>
<div class="listingblock">
<div class="title">Crear un contenedor sin red:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run --network none nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_overlay">overlay</h4>
<div class="paragraph">
<p>Permite la comunicación entre contenedores en diferentes hosts, ideal para clústeres y orquestadores como Docker Swarm. Requiere configuración adicional y un entorno distribuido.</p>
</div>
<div class="listingblock">
<div class="title">Crear una red overlay:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create --driver overlay mi_red_overlay</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_macvlan">macvlan</h4>
<div class="paragraph">
<p>Asigna una dirección MAC y una IP propia al contenedor, integrándolo directamente en la red física del host. Es útil para aplicaciones que necesitan ser vistas como dispositivos físicos en la red.</p>
</div>
<div class="listingblock">
<div class="title">Crear una red macvlan:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create -d macvlan \
  --subnet=192.168.1.0/24 \
  --gateway=192.168.1.1 \
  -o parent=eth0 mi_red_macvlan</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_comparativo">Resumen comparativo</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo de red</th>
<th class="tableblock halign-left valign-top">Características principales</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bridge</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Por defecto, comunicación entre contenedores en el mismo host</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sin aislamiento, acceso directo a la red del host</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sin conectividad de red</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">overlay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comunicación entre hosts (Swarm, clúster)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">macvlan</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP/MAC propia en la red física</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_comunicación_entre_contenedores">Comunicación entre contenedores</h3>
<div class="paragraph">
<p>La comunicación entre contenedores es esencial para construir aplicaciones distribuidas y sistemas de microservicios. Docker facilita esta comunicación mediante redes virtuales, permitiendo que los contenedores se descubran y se comuniquen de forma segura y eficiente.</p>
</div>
<div class="sect3">
<h4 id="_comunicación_en_la_red_bridge_por_defecto">Comunicación en la red bridge (por defecto)</h4>
<div class="paragraph">
<p>Cuando varios contenedores están conectados a la misma red bridge (la red por defecto o una personalizada), pueden comunicarse entre sí usando el nombre del contenedor como hostname.</p>
</div>
<div class="listingblock">
<div class="title">Crear una red bridge personalizada y conectar contenedores:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create mi_red_bridge
docker run -d --name app1 --network mi_red_bridge nginx
docker run -d --name app2 --network mi_red_bridge alpine sleep infinity</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Comprobar la conectividad desde app2 a app1 usando ping:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec -it app2 ping -c 3 app1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comunicación_usando_nombres_de_contenedor">Comunicación usando nombres de contenedor</h4>
<div class="listingblock">
<div class="title">Docker añade automáticamente los nombres de los contenedores al DNS interno de la red. Así, puedes acceder a servicios usando el nombre del contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Desde app2, acceder al puerto 80 de app1 (nginx)
docker exec -it app2 apk add --no-cache curl
docker exec -it app2 curl http://app1:80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comunicación_entre_redes_diferentes">Comunicación entre redes diferentes</h4>
<div class="listingblock">
<div class="title">Por defecto, los contenedores en diferentes redes no pueden comunicarse. Para permitirlo, debes conectar el contenedor a varias redes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create red1
docker network create red2
docker run -d --name multiapp --network red1 alpine sleep infinity
docker network connect red2 multiapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora, <code>multiapp</code> puede comunicarse con contenedores en ambas redes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exposición_de_servicios_al_exterior">Exposición de servicios al exterior</h4>
<div class="listingblock">
<div class="title">Para que un contenedor sea accesible desde fuera del host Docker, debes mapear puertos con la opción <code>-p</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name web -p 8080:80 nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto permite acceder a nginx en el puerto 8080 del host.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_2">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa redes personalizadas para aislar y organizar servicios.</p>
</li>
<li>
<p>Utiliza nombres de contenedor para facilitar la comunicación y el descubrimiento de servicios.</p>
</li>
<li>
<p>Limita la exposición de puertos solo a los servicios que realmente deban ser accesibles desde fuera.</p>
</li>
<li>
<p>Documenta la topología de red de tus aplicaciones multicontenedor.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exposición_y_mapeo_de_puertos">Exposición y mapeo de puertos</h3>
<div class="paragraph">
<p>Exponer y mapear puertos es fundamental para que los servicios que corren dentro de los contenedores Docker sean accesibles desde el host o desde redes externas. Docker proporciona varias formas de controlar cómo se exponen los puertos y cómo se enruta el tráfico hacia los contenedores.</p>
</div>
<div class="sect3">
<h4 id="_exponer_puertos_en_el_dockerfile">Exponer puertos en el Dockerfile</h4>
<div class="paragraph">
<p>La instrucción <code>EXPOSE</code> en el Dockerfile documenta qué puertos utiliza la aplicación dentro del contenedor. No publica el puerto automáticamente, pero sirve como referencia para usuarios y herramientas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">EXPOSE 80
EXPOSE 443</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapeo_de_puertos_al_ejecutar_un_contenedor">Mapeo de puertos al ejecutar un contenedor</h4>
<div class="paragraph">
<p>Para hacer accesible un puerto del contenedor desde el host, utiliza la opción <code>-p</code> o <code>--publish</code> al ejecutar <code>docker run</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name web -p 8080:80 nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto mapea el puerto 80 del contenedor al puerto 8080 del host. Ahora puedes acceder a nginx en <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Sintaxis general: <code>-p &lt;puerto_host&gt;:&lt;puerto_contenedor&gt;</code></p>
</li>
<li>
<p>Puedes mapear varios puertos repitiendo la opción <code>-p</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d -p 8080:80 -p 8443:443 nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapeo_de_puertos_en_modo_aleatorio">Mapeo de puertos en modo aleatorio</h4>
<div class="listingblock">
<div class="title">Si solo especificas el puerto del contenedor, Docker asigna un puerto aleatorio del host:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d -p 80 nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Consulta el puerto asignado con:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker port &lt;nombre_o_id_contenedor&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapeo_de_puertos_en_interfaces_específicas">Mapeo de puertos en interfaces específicas</h4>
<div class="listingblock">
<div class="title">Puedes limitar la exposición a una interfaz de red específica del host:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d -p 127.0.0.1:8080:80 nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto hace que el servicio solo sea accesible desde localhost.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_2">Ejemplo práctico</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Ejecutar un contenedor de nginx accesible en el puerto 8080 del host
docker run -d --name miweb -p 8080:80 nginx

# Verificar los puertos mapeados
docker ps

# Acceder al servicio desde el navegador o curl
curl http://localhost:8080</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_3">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Expón solo los puertos necesarios para reducir la superficie de ataque.</p>
</li>
<li>
<p>Usa interfaces específicas para limitar el acceso externo si es necesario.</p>
</li>
<li>
<p>Documenta los puertos expuestos en el Dockerfile y en la documentación del proyecto.</p>
</li>
<li>
<p>En entornos de producción, utiliza un proxy inverso o balanceador de carga para gestionar el acceso a los servicios.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dns_y_nombres_de_host">DNS y nombres de host</h3>
<div class="paragraph">
<p>Docker proporciona un sistema de resolución de nombres (DNS interno) que facilita la comunicación entre contenedores dentro de la misma red. Esto permite que los contenedores se descubran y se conecten usando nombres lógicos en lugar de direcciones IP, lo que mejora la portabilidad y la flexibilidad de las aplicaciones.</p>
</div>
<div class="sect3">
<h4 id="_resolución_automática_de_nombres">Resolución automática de nombres</h4>
<div class="paragraph">
<p>Cuando creas contenedores en una red bridge personalizada o en una red overlay, Docker añade automáticamente los nombres de los contenedores al DNS interno de esa red. Así, puedes acceder a un contenedor usando su nombre como hostname.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create mi_red
docker run -d --name web --network mi_red nginx
docker run -d --name cliente --network mi_red alpine sleep infinity
docker exec -it cliente ping -c 3 web</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, el contenedor <code>cliente</code> puede resolver el nombre <code>web</code> y comunicarse con él sin necesidad de conocer su IP.</p>
</div>
</div>
<div class="sect3">
<h4 id="_alias_de_red">Alias de red</h4>
<div class="listingblock">
<div class="title">Puedes asignar alias adicionales a un contenedor dentro de una red, facilitando el acceso con diferentes nombres.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name app --network mi_red --network-alias servicio nginx
docker exec -it cliente ping servicio</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_personalización_del_hostname">Personalización del hostname</h4>
<div class="paragraph">
<p>Puedes definir el hostname de un contenedor usando la opción <code>--hostname</code> al crear el contenedor.</p>
</div>
<div class="listingblock">
<div class="title">Esto es útil para aplicaciones que dependen de un nombre de host específico o para facilitar la identificación de contenedores en la red.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name db --hostname basededatos --network mi_red mysql</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dentro de ese contenedor, el hostname será <code>basededatos</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_modificación_del_archivo_etchosts">Modificación del archivo /etc/hosts</h4>
<div class="paragraph">
<p>Docker permite añadir entradas personalizadas al archivo <code>/etc/hosts</code> del contenedor usando la opción <code>--add-host</code>.</p>
</div>
<div class="listingblock">
<div class="title">Esto es útil para resolver nombres de host específicos a direcciones IP concretas.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name app --add-host api.local:172.18.0.10 nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto añade la línea <code>172.18.0.10 api.local</code> al <code>/etc/hosts</code> del contenedor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_descubrimiento_de_servicios_en_redes_overlay">Descubrimiento de servicios en redes overlay</h4>
<div class="paragraph">
<p>En redes overlay (usadas en Docker Swarm), el DNS interno permite descubrir servicios por nombre de servicio, facilitando el balanceo de carga y la alta disponibilidad.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, si tienes un servicio llamado <code>web</code> en una red overlay, puedes acceder a él desde otros servicios usando el nombre <code>web</code>.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service create --name web --network mi_overlay nginx
docker service create --name cliente --network mi_overlay alpine sleep infinity
docker exec -it $(docker ps -q -f name=cliente) ping web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_4">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa nombres descriptivos y consistentes para los contenedores y servicios.</p>
</li>
<li>
<p>Prefiere redes personalizadas para aprovechar el DNS interno de Docker.</p>
</li>
<li>
<p>Utiliza alias de red para facilitar migraciones o cambios de arquitectura.</p>
</li>
<li>
<p>Documenta los nombres y alias utilizados en la arquitectura de tu aplicación.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creación_y_gestión_de_redes_personalizadas">Creación y gestión de redes personalizadas</h3>
<div class="paragraph">
<p>Docker permite crear redes personalizadas para aislar, organizar y controlar la comunicación entre contenedores. Las redes personalizadas ofrecen ventajas como el aislamiento, la facilidad de descubrimiento de servicios y la configuración avanzada de topologías de red.</p>
</div>
<div class="sect3">
<h4 id="_por_qué_usar_redes_personalizadas">¿Por qué usar redes personalizadas?</h4>
<div class="ulist">
<ul>
<li>
<p>Aislamiento entre aplicaciones o entornos (desarrollo, pruebas, producción).</p>
</li>
<li>
<p>Control granular sobre la comunicación entre contenedores.</p>
</li>
<li>
<p>Facilita el uso de DNS interno y alias de red.</p>
</li>
<li>
<p>Permite definir políticas de red y opciones avanzadas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_crear_una_red_personalizada">Crear una red personalizada</h4>
<div class="listingblock">
<div class="title">Puedes crear una red bridge personalizada (la más común para un solo host) con:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create mi_red_personalizada</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para ver todas las redes disponibles:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network ls</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_conectar_contenedores_a_una_red_personalizada">Conectar contenedores a una red personalizada</h4>
<div class="listingblock">
<div class="title">Al crear un contenedor, usa la opción <code>--network</code> para conectarlo a una red específica:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name app1 --network mi_red_personalizada nginx
docker run -d --name app2 --network mi_red_personalizada alpine sleep infinity</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora, <code>app1</code> y <code>app2</code> pueden comunicarse usando sus nombres como hostname.</p>
</div>
</div>
<div class="sect3">
<h4 id="_conectar_un_contenedor_existente_a_otra_red">Conectar un contenedor existente a otra red</h4>
<div class="listingblock">
<div class="title">Puedes conectar un contenedor ya creado a una red adicional:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network connect mi_red_personalizada app2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inspeccionar_y_gestionar_redes">Inspeccionar y gestionar redes</h4>
<div class="listingblock">
<div class="title">Para ver los detalles y configuración de una red:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network inspect mi_red_personalizada</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para desconectar un contenedor de una red:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network disconnect mi_red_personalizada app2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eliminar_una_red_personalizada">Eliminar una red personalizada</h4>
<div class="listingblock">
<div class="title">Solo puedes eliminar una red si no tiene contenedores conectados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network rm mi_red_personalizada</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_completo">Ejemplo práctico completo</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Crear una red personalizada
docker network create mi_red

# Crear dos contenedores en esa red
docker run -d --name web --network mi_red nginx
docker run -d --name cliente --network mi_red alpine sleep infinity

# Comprobar conectividad
docker exec -it cliente ping -c 3 web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_redes_avanzadas_overlay_y_macvlan">Redes avanzadas: overlay y macvlan</h4>
<div class="ulist">
<ul>
<li>
<p>Para clústeres y comunicación entre hosts, usa redes <code>overlay</code> (requiere Docker Swarm).</p>
</li>
<li>
<p>Para integración directa con la red física, usa <code>macvlan</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_5">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa redes personalizadas para aislar aplicaciones y entornos.</p>
</li>
<li>
<p>Asigna nombres descriptivos a las redes.</p>
</li>
<li>
<p>Documenta la topología de red de tus aplicaciones.</p>
</li>
<li>
<p>Elimina redes que ya no utilices para mantener el entorno limpio.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_persistencia_de_datos">Persistencia de Datos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La persistencia de datos es fundamental en Docker, ya que por defecto los datos generados dentro de un contenedor se pierden al eliminarlo. Para garantizar que la información sobreviva al ciclo de vida de los contenedores, Docker ofrece varias soluciones: volúmenes, montajes de enlace (bind mounts) y estrategias de backup. En este enderás a gestionar datos de forma segura y eficiente.</p>
</div>
<div class="sect2">
<h3 id="_volúmenes_docker">Volúmenes Docker</h3>
<div class="paragraph">
<p>Los volúmenes son la forma recomendada por Docker para gestionar la persistencia de datos fuera del ciclo de vida de los contenedores. Un volumen es un área gestionada por Docker en el sistema de archivos del host, independiente de cualquier contenedor específico.</p>
</div>
<div class="sect3">
<h4 id="_por_qué_usar_volúmenes">¿Por qué usar volúmenes?</h4>
<div class="ulist">
<ul>
<li>
<p>Los datos almacenados en volúmenes persisten aunque el contenedor se elimine o recree.</p>
</li>
<li>
<p>Permiten compartir datos entre varios contenedores.</p>
</li>
<li>
<p>Facilitan la realización de backups y restauraciones.</p>
</li>
<li>
<p>Mejoran el rendimiento y la seguridad frente a los bind mounts tradicionales.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_crear_y_gestionar_volúmenes">Crear y gestionar volúmenes</h4>
<div class="listingblock">
<div class="title">Crear un volumen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker volume create datos_app</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listar volúmenes existentes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker volume ls</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Inspeccionar detalles de un volumen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker volume inspect datos_app</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar un volumen (debe estar sin uso):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker volume rm datos_app</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_usar_volúmenes_en_contenedores">Usar volúmenes en contenedores</h4>
<div class="listingblock">
<div class="title">Montar un volumen en un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name app -v datos_app:/var/lib/appdata myimage</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, todo lo que la aplicación escriba en <code>/var/lib/appdata</code> se almacenará en el volumen <code>datos_app</code> y persistirá aunque el contenedor se elimine.</p>
</div>
<div class="listingblock">
<div class="title">Montar un volumen en modo solo lectura:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d -v datos_app:/datos:ro myimage</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compartir_volúmenes_entre_contenedores">Compartir volúmenes entre contenedores</h4>
<div class="listingblock">
<div class="title">Puedes montar el mismo volumen en varios contenedores para compartir datos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name app1 -v datos_app:/data myimage
docker run -d --name app2 -v datos_app:/data myimage</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ubicación_de_los_volúmenes">Ubicación de los volúmenes</h4>
<div class="paragraph">
<p>Por defecto, Docker almacena los volúmenes en <code>/var/lib/docker/volumes/</code> en el host, pero su gestión debe hacerse siempre con los comandos de Docker.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_3">Ejemplo práctico</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Crear un volumen
docker volume create datos_web

# Ejecutar un contenedor de nginx usando el volumen para los archivos estáticos
docker run -d --name web -v datos_web:/usr/share/nginx/html nginx

# Copiar archivos desde el host al volumen (usando un contenedor temporal)
docker cp index.html web:/usr/share/nginx/html/index.html</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_6">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa volúmenes para datos que deban persistir o compartirse entre contenedores.</p>
</li>
<li>
<p>No almacenes datos importantes solo en el sistema de archivos interno del contenedor.</p>
</li>
<li>
<p>Realiza backups periódicos de los volúmenes.</p>
</li>
<li>
<p>Elimina volúmenes que ya no utilices para liberar espacio.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_3">Resumen</h4>
<div class="paragraph">
<p>Los volúmenes Docker son la solución más robusta y flexible para la persistencia de datos en entornos de contenedores, facilitando la gestión, el backup y la portabilidad de la información.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_montajes_de_enlace_bind_mounts">Montajes de enlace (bind mounts)</h3>
<div class="paragraph">
<p>Los montajes de enlace (bind mounts) permiten montar un directorio o archivo específico del sistema de archivos del host directamente dentro de un contenedor. A diferencia de los volúmenes gestionados por Docker, los bind mounts ofrecen un control total sobre la ubicación y el contenido, lo que resulta útil para desarrollo, pruebas y casos donde se requiere acceso directo a archivos del host.</p>
</div>
<div class="sect3">
<h4 id="_cuándo_usar_bind_mounts">¿Cuándo usar bind mounts?</h4>
<div class="ulist">
<ul>
<li>
<p>Cuando necesitas que los cambios en los archivos del host se reflejen inmediatamente en el contenedor (ideal para desarrollo).</p>
</li>
<li>
<p>Para compartir archivos de configuración, código fuente o datos temporales entre el host y el contenedor.</p>
</li>
<li>
<p>Cuando se requiere acceso a rutas específicas del host que no pueden gestionarse como volúmenes Docker.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_sintaxis_y_uso_básico">Sintaxis y uso básico</h4>
<div class="paragraph">
<p>La sintaxis general para usar un bind mount es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d -v /ruta/del/host:/ruta/en/contenedor imagen</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para montar el directorio actual en <code>/app</code> dentro del contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d -v $(pwd):/app python:3.11-slim</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_modo_de_solo_lectura">Modo de solo lectura</h4>
<div class="listingblock">
<div class="title">Puedes montar el directorio en modo solo lectura agregando <code>:ro</code> al final:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d -v /ruta/del/host:/ruta/en/contenedor:ro nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_4">Ejemplo práctico</h4>
<div class="listingblock">
<div class="title">Supón que tienes un archivo <code>index.html</code> en tu máquina y quieres servirlo con nginx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name web \
  -v $(pwd)/index.html:/usr/share/nginx/html/index.html \
  -p 8080:80 nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cualquier cambio en <code>index.html</code> en el host se reflejará inmediatamente en el contenedor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_consideraciones_de_seguridad_y_permisos_2">Consideraciones de seguridad y permisos</h4>
<div class="ulist">
<ul>
<li>
<p>El contenedor tendrá acceso a los archivos del host según los permisos del usuario que ejecuta Docker.</p>
</li>
<li>
<p>Evita montar directorios sensibles del sistema para reducir riesgos de seguridad.</p>
</li>
<li>
<p>En entornos de producción, prefiere volúmenes gestionados por Docker para mayor aislamiento y portabilidad.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_diferencias_entre_bind_mounts_y_volúmenes">Diferencias entre bind mounts y volúmenes</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bind Mounts</th>
<th class="tableblock halign-left valign-top">Volúmenes Docker</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Montan cualquier ruta del host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gestionados por Docker en rutas internas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cambios inmediatos entre host y contenedor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aislados del sistema de archivos del host</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Útiles para desarrollo y pruebas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recomendados para producción y persistencia</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Menos portables</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Más portables y fáciles de respaldar</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_7">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa bind mounts para desarrollo, pruebas o integración con herramientas externas.</p>
</li>
<li>
<p>Documenta claramente las rutas montadas para evitar confusiones.</p>
</li>
<li>
<p>No montes rutas del sistema o directorios críticos del host.</p>
</li>
<li>
<p>Prefiere volúmenes para datos persistentes y en producción.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estrategias_de_backup_y_restauración">Estrategias de backup y restauración</h3>
<div class="paragraph">
<p>La protección y recuperación de datos es esencial en cualquier entorno de contenedores. Docker facilita el backup y la restauración de datos principalmente a través de volúmenes y bind mounts. A continuación se presentan estrategias didácticas y ejemplos prácticos para realizar copias de seguridad y restaurar datos de manera segura y eficiente.</p>
</div>
<div class="sect3">
<h4 id="_backup_y_restauración_de_volúmenes_docker">Backup y restauración de volúmenes Docker</h4>
<div class="paragraph">
<p>Los volúmenes son la forma recomendada de persistir datos en Docker. Puedes respaldar y restaurar su contenido fácilmente usando contenedores temporales y comandos estándar de Linux.</p>
</div>
<div class="listingblock">
<div class="title">Backup de un volumen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run --rm -v datos_app:/datos -v $(pwd):/backup alpine \
  tar czf /backup/backup_datos_app.tar.gz -C /datos .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este comando crea un archivo comprimido <code>backup_datos_app.tar.gz</code> en el directorio actual del host con todo el contenido del volumen <code>datos_app</code>.</p>
</div>
<div class="listingblock">
<div class="title">Restauración de un volumen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run --rm -v datos_app:/datos -v $(pwd):/backup alpine \
  tar xzf /backup/backup_datos_app.tar.gz -C /datos</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_backup_y_restauración_de_bind_mounts">Backup y restauración de bind mounts</h4>
<div class="paragraph">
<p>Como los bind mounts son directorios o archivos del host, puedes usar cualquier herramienta de backup tradicional (rsync, cp, tar, etc.) directamente sobre la ruta del host.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo usando tar:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">tar czf backup_mis_datos.tar.gz /ruta/del/host
# Para restaurar:
tar xzf backup_mis_datos.tar.gz -C /ruta/del/host</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_backup_y_restauración_de_bases_de_datos_en_contenedores">Backup y restauración de bases de datos en contenedores</h4>
<div class="paragraph">
<p>Para bases de datos como MySQL o PostgreSQL, es recomendable usar las herramientas propias de backup (mysqldump, pg_dump) ejecutadas dentro del contenedor.</p>
</div>
<div class="listingblock">
<div class="title">Backup de una base de datos MySQL:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec mi_mysql_container \
  mysqldump -u usuario -p'contraseña' basededatos &gt; backup.sql</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Restauración:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker exec -i mi_mysql_container \
  mysql -u usuario -p'contraseña' basededatos &lt; backup.sql</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_automatización_y_buenas_prácticas">Automatización y buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Programa backups periódicos usando cron jobs en el host o contenedores dedicados.</p>
</li>
<li>
<p>Almacena los backups fuera del host Docker para mayor seguridad.</p>
</li>
<li>
<p>Verifica regularmente la integridad de los backups y realiza pruebas de restauración.</p>
</li>
<li>
<p>Documenta el procedimiento de backup y restauración para tu equipo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_completo_backup_y_restauración_de_un_volumen">Ejemplo completo: backup y restauración de un volumen</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Crear un volumen y un contenedor de ejemplo
docker volume create datos_web
docker run -d --name web -v datos_web:/usr/share/nginx/html nginx

# Backup del volumen
docker run --rm -v datos_web:/datos -v $(pwd):/backup alpine \
  tar czf /backup/backup_web.tar.gz -C /datos .

# Restaurar el volumen en otro host o entorno
docker volume create datos_web_restaurado
docker run --rm -v datos_web_restaurado:/datos -v $(pwd):/backup alpine \
  tar xzf /backup/backup_web.tar.gz -C /datos</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_4">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p>Utiliza volúmenes para facilitar el backup y la restauración de datos.</p>
</li>
<li>
<p>Usa herramientas estándar (tar, rsync) y contenedores temporales para manipular datos.</p>
</li>
<li>
<p>Automatiza y documenta los procesos de backup y restauración para garantizar la continuidad del negocio y la recuperación ante desastres.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compartir_datos_entre_contenedores">Compartir datos entre contenedores</h3>
<div class="paragraph">
<p>Compartir datos entre contenedores es una necesidad común en arquitecturas de microservicios y aplicaciones distribuidas. Docker facilita este intercambio principalmente a través de volúmenes, permitiendo que varios contenedores accedan y modifiquen la misma información de manera eficiente y segura.</p>
</div>
<div class="sect3">
<h4 id="_compartir_volúmenes_entre_contenedores_2">Compartir volúmenes entre contenedores</h4>
<div class="paragraph">
<p>La forma más sencilla y recomendada de compartir datos es montar el mismo volumen en varios contenedores.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo práctico:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Crear un volumen
docker volume create datos_compartidos

# Ejecutar el primer contenedor con el volumen
docker run -d --name productor -v datos_compartidos:/datos busybox sh -c "while true; do date &gt;&gt; /datos/fechas.txt; sleep 1; done"

# Ejecutar el segundo contenedor con el mismo volumen
docker run -it --name consumidor -v datos_compartidos:/datos busybox tail -f /datos/fechas.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, el contenedor <code>productor</code> escribe continuamente en un archivo dentro del volumen, y el contenedor <code>consumidor</code> puede leer esos datos en tiempo real.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compartir_bind_mounts">Compartir bind mounts</h4>
<div class="listingblock">
<div class="title">También puedes usar un bind mount para que varios contenedores accedan a un mismo directorio del host.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name app1 -v /tmp/datos:/compartido busybox
docker run -d --name app2 -v /tmp/datos:/compartido busybox</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ambos contenedores verán y podrán modificar los archivos en <code>/tmp/datos</code> del host.</p>
</div>
</div>
<div class="sect3">
<h4 id="_volúmenes_data_only_contenedores_de_datos">Volúmenes "data-only" (contenedores de datos)</h4>
<div class="paragraph">
<p>Antes de Docker 1.9, era común crear contenedores dedicados solo para almacenar datos y compartirlos con otros contenedores usando la opción <code>--volumes-from</code>. Aunque hoy se prefiere usar volúmenes directamente, este método aún es válido en algunos casos.</p>
</div>
<div class="listingblock">
<div class="title">Crear un contenedor de datos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># Crear un contenedor de datos
docker create -v /datos --name datos_container busybox

# Montar el volumen de datos_container en otros contenedores
docker run -d --name app1 --volumes-from datos_container busybox
docker run -d --name app2 --volumes-from datos_container busybox</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consideraciones_de_concurrencia_y_permisos">Consideraciones de concurrencia y permisos</h4>
<div class="ulist">
<ul>
<li>
<p>Todos los contenedores que comparten un volumen pueden leer y escribir en él simultáneamente.</p>
</li>
<li>
<p>Es importante que las aplicaciones gestionen correctamente el acceso concurrente a los archivos para evitar corrupción de datos.</p>
</li>
<li>
<p>Los permisos de los archivos y directorios deben ser compatibles con los usuarios de todos los contenedores que acceden al volumen.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_8">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Prioriza usar volúmenes Docker para compartir datos entre contenedores, ya que son más portables y seguros.</p>
</li>
<li>
<p>Documenta qué contenedores comparten cada volumen y para qué propósito.</p>
</li>
<li>
<p>Si necesitas compartir datos solo en modo lectura, monta el volumen como <code>:ro</code> en los contenedores consumidores.</p>
</li>
<li>
<p>Evita compartir volúmenes entre contenedores que ejecutan aplicaciones con diferentes requisitos de seguridad o aislamiento.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_persistencia_en_entornos_de_producción">Persistencia en entornos de producción</h3>
<div class="paragraph">
<p>La persistencia de datos en entornos de producción requiere estrategias más robustas y seguras que en desarrollo. Es fundamental garantizar la integridad, disponibilidad y rendimiento de los datos, así como facilitar la escalabilidad y la recuperación ante fallos. A continuación se presentan recomendaciones y buenas prácticas para gestionar la persistencia en producción con Docker.</p>
</div>
<div class="sect3">
<h4 id="_usa_volúmenes_gestionados_por_docker_o_soluciones_externas">Usa volúmenes gestionados por Docker o soluciones externas</h4>
<div class="ulist">
<ul>
<li>
<p>Prefiere volúmenes Docker (<code>docker volume</code>) sobre bind mounts para mayor portabilidad y aislamiento.</p>
</li>
<li>
<p>Para aplicaciones críticas, considera soluciones de almacenamiento externas y distribuidas (NFS, GlusterFS, Ceph, Amazon EFS, Azure Files, etc.) que permitan alta disponibilidad y redundancia.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_monta_volúmenes_en_rutas_específicas">Monta volúmenes en rutas específicas</h4>
<div class="ulist">
<ul>
<li>
<p>Define rutas de montaje claras y documentadas para los datos persistentes.</p>
</li>
<li>
<p>Evita almacenar datos importantes en el sistema de archivos interno del contenedor.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name db \
  -v datos_db:/var/lib/mysql \
  mysql:8</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestiona_permisos_y_usuarios">Gestiona permisos y usuarios</h4>
<div class="ulist">
<ul>
<li>
<p>Asegúrate de que los volúmenes tengan los permisos adecuados para el usuario que ejecuta la aplicación dentro del contenedor.</p>
</li>
<li>
<p>Evita ejecutar aplicaciones como root; usa usuarios específicos para cada servicio.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_realiza_backups_y_pruebas_de_restauración_periódicas">Realiza backups y pruebas de restauración periódicas</h4>
<div class="ulist">
<ul>
<li>
<p>Automatiza copias de seguridad de los volúmenes y verifica regularmente que los backups sean restaurables.</p>
</li>
<li>
<p>Almacena los backups fuera del host Docker para mayor seguridad.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_monitoriza_el_uso_de_espacio_y_el_rendimiento">Monitoriza el uso de espacio y el rendimiento</h4>
<div class="ulist">
<ul>
<li>
<p>Supervisa el espacio disponible en los volúmenes y el rendimiento de I/O.</p>
</li>
<li>
<p>Configura alertas para evitar interrupciones por falta de espacio o degradación del rendimiento.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_usa_volúmenes_con_cifrado_y_replicación_si_es_necesario">Usa volúmenes con cifrado y replicación si es necesario</h4>
<div class="ulist">
<ul>
<li>
<p>Para datos sensibles, utiliza volúmenes cifrados o soluciones de almacenamiento que soporten cifrado en reposo.</p>
</li>
<li>
<p>Considera la replicación de datos para alta disponibilidad y tolerancia a fallos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_orquestadores_y_almacenamiento_persistente">Orquestadores y almacenamiento persistente</h4>
<div class="ulist">
<ul>
<li>
<p>Si usas orquestadores como Docker Swarm o Kubernetes, utiliza drivers de volúmenes compatibles con almacenamiento persistente y dinámico (por ejemplo, StorageClass en Kubernetes).</p>
</li>
<li>
<p>Define políticas de retención y recuperación de datos en el clúster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_uso_de_nfs_como_volumen_externo">Ejemplo: uso de NFS como volumen externo</h4>
<div class="paragraph">
<p>Para usar un servidor NFS como almacenamiento persistente, primero asegúrate de que el servidor NFS esté configurado y accesible desde el host Docker. Luego, crea un volumen Docker que use NFS como backend.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de creación de un volumen NFS:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker volume create --driver local \
  --opt type=nfs \
  --opt o=addr=192.168.1.100,rw \
  --opt device=:/ruta/nfs/datos \
  datos_nfs

docker run -d --name app -v datos_nfs:/app/datos myimage</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_adicionales">Buenas prácticas adicionales</h4>
<div class="ulist">
<ul>
<li>
<p>Documenta la estrategia de persistencia y recuperación de datos.</p>
</li>
<li>
<p>Separa los datos de configuración, logs y datos de usuario en diferentes volúmenes si es posible.</p>
</li>
<li>
<p>Elimina volúmenes y datos obsoletos para evitar acumulación innecesaria.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_docker_buildx">Docker Buildx</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introducción_a_docker_buildx">Introducción a Docker Buildx</h3>
<div class="paragraph">
<p>Docker Buildx es una extensión de la CLI de Docker que proporciona capacidades avanzadas para construir imágenes de contenedores gracias a su integración directa con BuildKit, el motor de compilación de nueva generación de Docker. Buildx amplía las capacidades tradicionales de <code>docker build</code>, permitiendo, entre otras cosas, la creación de imágenes multiplataforma, la gestión avanzada de caché y la ejecución de compilaciones en paralelo, todo desde la misma interfaz de Docker.</p>
</div>
<div class="paragraph">
<p>Buildx funciona bajo un modelo cliente-servidor: Buildx actúa como cliente e interfaz de usuario, mientras que BuildKit es el servidor (o "builder") que ejecuta realmente los pasos de la compilación. Cuando ejecutas un comando como <code>docker buildx build</code>, la CLI de Docker (Buildx) envía una solicitud de compilación al backend de BuildKit, que se encarga de procesar las instrucciones del Dockerfile, gestionar argumentos, cachés y exportar los resultados en el formato deseado.</p>
</div>
<div class="paragraph">
<p>Esta arquitectura permite que BuildKit realice optimizaciones que el constructor heredado de Docker no puede, como la ejecución de etapas independientes en paralelo y el uso eficiente de la caché, lo que resulta en compilaciones más rápidas y reproducibles. Además, Buildx permite gestionar múltiples "builders" (instancias de BuildKit), tanto locales como remotos, facilitando la escalabilidad y la integración con infraestructuras de CI/CD o clústeres de Kubernetes.</p>
</div>
<div class="paragraph">
<p>En resumen, Buildx es la interfaz avanzada y flexible para construir imágenes Docker, mientras que BuildKit es el motor subyacente que ejecuta la compilación de manera eficiente y moderna.</p>
</div>
<div class="ulist">
<div class="title">Aunque ambos comandos (<code>docker build</code> y <code>docker buildx build</code>) utilizan BuildKit como motor de compilación en las versiones modernas de Docker, existen diferencias clave en su alcance y funcionalidad:</div>
<ul>
<li>
<p><code>docker build</code> es esencialmente un alias de <code>docker buildx build</code> en las versiones recientes de Docker, ya que ambos invocan BuildKit por defecto. Sin embargo, <code>docker build</code> ejecuta las compilaciones usando el builder por defecto (driver <code>docker</code>), que tiene funcionalidades limitadas y requiere menos configuración.</p>
</li>
<li>
<p><code>docker buildx build</code> es un superconjunto de <code>docker build</code> y expone todas las capacidades avanzadas de BuildKit. Permite:</p>
<div class="ulist">
<ul>
<li>
<p>Crear y gestionar múltiples "builders" (instancias de BuildKit) con diferentes configuraciones y drivers (por ejemplo, <code>docker-container</code>, <code>remote</code>), lo que facilita la construcción en diferentes entornos o arquitecturas.</p>
</li>
<li>
<p>Construir imágenes multiplataforma (multi-arch) de forma nativa y sencilla, algo que <code>docker build</code> no soporta completamente sin configuraciones adicionales.</p>
</li>
<li>
<p>Ejecutar builds en paralelo y aprovechar estrategias avanzadas de caché, tanto local como remota o embebida en el registro, optimizando tiempos y recursos.</p>
</li>
<li>
<p>Usar opciones avanzadas como <code>--output</code>, <code>--cache-from</code>, <code>--cache-to</code>, <code>--secret</code>, <code>--ssh</code>, y otras que no están disponibles o son limitadas en <code>docker build</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>En resumen:</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>docker build</code></th>
<th class="tableblock halign-left valign-top"><code>docker buildx build</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alias de Buildx, usa el builder por defecto (driver <code>docker</code>). Limitado en funcionalidades avanzadas.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Permite gestionar múltiples builders, drivers y configuraciones avanzadas.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Soporte básico para builds; multi-arquitectura solo con hacks o configuraciones externas.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Soporte nativo para builds multiplataforma, caché avanzada y outputs flexibles.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Menor flexibilidad y personalización.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Máxima flexibilidad, ideal para CI/CD, builds distribuidos y optimización de recursos.</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<div class="title">Buildx amplía significativamente las capacidades de construcción de imágenes en Docker, aportando ventajas clave que lo convierten en la herramienta recomendada para flujos de trabajo modernos:</div>
<ul>
<li>
<p>Multi-arquitectura (multiplataforma):</p>
<div class="ulist">
<ul>
<li>
<p>Permite construir imágenes para varias arquitecturas de CPU (por ejemplo, amd64, arm64, arm/v7) en una sola línea de comando, generando un manifiesto multiarquitectura (“fat manifest”) que facilita el despliegue en entornos heterogéneos como servidores x86, dispositivos IoT, o clusters mixtos.</p>
</li>
<li>
<p>Utiliza emulación (QEMU) o builders nativos para cada plataforma, lo que simplifica el proceso y elimina la necesidad de configuraciones complejas o scripts adicionales.</p>
</li>
<li>
<p>Ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --platform linux/amd64,linux/arm64 -t usuario/imagen:tag --push .</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Caché avanzada:</p>
<div class="ulist">
<ul>
<li>
<p>Implementa una estrategia de caché de tres niveles: caché incrustada en la imagen, caché local y caché basada en registros remotos.</p>
</li>
<li>
<p>Permite compartir la caché entre diferentes máquinas o entornos, ideal para equipos distribuidos y pipelines CI/CD.</p>
</li>
<li>
<p>Mejora drásticamente los tiempos de construcción al reutilizar capas previas, incluso entre builds en distintas plataformas o entornos.</p>
</li>
<li>
<p>Ejemplo de uso de caché local:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --cache-to type=local,dest=./buildcache -t myapp:latest .
docker buildx build --cache-from type=local,src=./buildcache -t myapp:latest .</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Paralelismo en la construcción:</p>
<div class="ulist">
<ul>
<li>
<p>Buildx puede analizar el Dockerfile y ejecutar etapas independientes en paralelo, aprovechando al máximo los recursos disponibles y reduciendo significativamente el tiempo total de construcción.</p>
</li>
<li>
<p>Esta capacidad es especialmente útil en builds complejos o multi-stage, donde varias dependencias pueden instalarse o compilarse simultáneamente.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Outputs flexibles:</p>
<div class="ulist">
<ul>
<li>
<p>Permite exportar el resultado de la build en diferentes formatos y destinos: imagen local, archivo tar, directorio, registro remoto, etc.</p>
</li>
<li>
<p>Facilita la integración con otros sistemas y la distribución de imágenes en distintos entornos de despliegue.</p>
</li>
<li>
<p>Ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --output type=tar,dest=miimagen.tar -t miapp:latest .</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Integración con clusters y CI/CD:</p>
<div class="ulist">
<ul>
<li>
<p>Puede distribuir las tareas de construcción en clusters Kubernetes, aprovechando la escalabilidad, alta disponibilidad y optimización de recursos de estos entornos.</p>
</li>
<li>
<p>Esto permite builds más rápidas y robustas, especialmente en equipos grandes o proyectos con necesidades de despliegue continuo.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>En resumen, Buildx ofrece una solución moderna, eficiente y flexible para construir imágenes Docker, facilitando la portabilidad, el rendimiento y la integración en infraestructuras de desarrollo y producción actuales.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conceptos_fundamentales">Conceptos Fundamentales</h3>
<div class="sect3">
<h4 id="_arquitectura_cliente_servidor_buildx_cliente_y_buildkit_servidor">Arquitectura cliente-servidor: Buildx (cliente) y BuildKit (servidor)</h4>
<div class="paragraph">
<p>Docker Buildx y BuildKit se basan en una arquitectura cliente-servidor que separa claramente la interfaz de usuario de la ejecución real de las compilaciones.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Buildx actúa como el cliente: es la herramienta de línea de comandos (CLI) que interpreta los comandos del usuario, gestiona las opciones de construcción y envía las solicitudes de build.</p>
</li>
<li>
<p>BuildKit es el servidor (o "builder"): es el demonio responsable de ejecutar las instrucciones del Dockerfile, gestionar la caché, realizar las etapas en paralelo y exportar los resultados.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cuando ejecutas un comando como <code>docker buildx build</code>, Buildx selecciona una instancia de constructor (builder), envía el contexto y las instrucciones de construcción al backend de BuildKit, y este último analiza el Dockerfile para crear un grafo de dependencias. BuildKit identifica qué pasos pueden ejecutarse en paralelo y optimiza la utilización de recursos, lo que acelera significativamente el proceso de construcción frente al modelo secuencial tradicional.</p>
</div>
<div class="ulist">
<div class="title">Esta arquitectura permite:</div>
<ul>
<li>
<p>Ejecución remota de builds: puedes dirigir tu CLI local a una instancia remota de BuildKit, por ejemplo, en un servidor potente, en la nube o en un clúster Kubernetes, sin consumir recursos locales innecesarios.</p>
</li>
<li>
<p>Flexibilidad y escalabilidad: puedes gestionar múltiples instancias de builder, cada una con configuraciones y capacidades distintas, adaptándose a diferentes necesidades de desarrollo y despliegue.</p>
</li>
<li>
<p>Eficiencia y modularidad: BuildKit solo solicita los recursos necesarios en el momento preciso (por ejemplo, archivos locales, secretos, credenciales), evitando transferencias innecesarias y mejorando la seguridad y el rendimiento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En resumen, la arquitectura cliente-servidor de Buildx y BuildKit permite desacoplar la interfaz de usuario de la ejecución de builds, facilitando construcciones más rápidas, escalables y adaptadas a entornos modernos y distribuidos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_qué_es_un_builder_y_para_qué_sirve">Qué es un "builder" y para qué sirve</h4>
<div class="paragraph">
<p>Un "builder" es una instancia del demonio BuildKit que se utiliza para ejecutar procesos de construcción de imágenes o artefactos a partir de un Dockerfile. En términos prácticos, un builder es el entorno (local o remoto) donde se llevan a cabo las compilaciones gestionadas por Buildx.</p>
</div>
<div class="paragraph">
<p>Los builders permiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ejecutar builds de forma independiente y aislada, cada uno con su propia configuración, caché y capacidades.</p>
</li>
<li>
<p>Gestionar múltiples entornos de construcción: puedes crear builders locales, en contenedores dedicados, en clusters de Kubernetes o en servidores remotos, según las necesidades del proyecto.</p>
</li>
<li>
<p>Seleccionar y cambiar fácilmente entre diferentes builders usando la CLI de Docker, lo que facilita la adaptación a distintos flujos de trabajo o plataformas.</p>
</li>
<li>
<p>Optimizar y escalar builds: al distribuir las tareas entre varios builders, puedes acelerar los tiempos de construcción y aprovechar recursos externos sin sobrecargar tu máquina local.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El builder predeterminado suele estar vinculado al demonio Docker local, pero puedes crear y gestionar otros builders con configuraciones personalizadas, por ejemplo, para builds multiplataforma o con caché compartida.</p>
</div>
<div class="paragraph">
<p>En resumen, un builder es la entidad que ejecuta los procesos de construcción en Docker Buildx, y su gestión flexible permite adaptar, escalar y optimizar los flujos de trabajo de construcción de imágenes en proyectos modernos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_drivers_disponibles_docker_docker_container_kubernetes_remote">Drivers disponibles: docker, docker-container, kubernetes, remote</h4>
<div class="paragraph">
<p>Buildx soporta varios drivers que determinan cómo y dónde se ejecuta el backend de BuildKit, permitiendo adaptar el entorno de construcción a diferentes necesidades y escenarios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>docker</code> (por defecto):</p>
<div class="ulist">
<ul>
<li>
<p>Utiliza la biblioteca BuildKit integrada en el demonio Docker.</p>
</li>
<li>
<p>Prioriza la simplicidad y facilidad de uso, pero tiene soporte limitado para funcionalidades avanzadas como exportación de caché o formatos de salida personalizados.</p>
</li>
<li>
<p>Las imágenes construidas aparecen automáticamente en el listado local de imágenes (<code>docker images</code>).</p>
</li>
<li>
<p>No soporta nativamente la construcción multiplataforma ni la exportación avanzada de caché.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>docker-container</code>:</p>
<div class="ulist">
<ul>
<li>
<p>Crea un entorno BuildKit dedicado en un contenedor Docker gestionado por Buildx.</p>
</li>
<li>
<p>Permite usar versiones personalizadas de BuildKit y soporta funcionalidades avanzadas como builds multiplataforma, exportación/importación de caché y configuración de recursos del contenedor (CPU, memoria, etc).</p>
</li>
<li>
<p>Las imágenes no aparecen automáticamente en el listado local; debes usar <code>--load</code> para cargarlas o <code>--push</code> para subirlas a un registro.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>kubernetes</code>:</p>
<div class="ulist">
<ul>
<li>
<p>Despliega pods BuildKit en un clúster de Kubernetes, permitiendo aprovechar la escalabilidad y recursos del clúster para builds distribuidos y de alto rendimiento.</p>
</li>
<li>
<p>Ideal para integraciones CI/CD en entornos empresariales o builds a gran escala.</p>
</li>
<li>
<p>Las imágenes tampoco aparecen automáticamente en el listado local; requiere <code>--load</code> o <code>--push</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>remote</code>:</p>
<div class="ulist">
<ul>
<li>
<p>Se conecta a una instancia de BuildKit gestionada manualmente, ya sea en otra máquina, en la nube o expuesta mediante un socket o endpoint TCP.</p>
</li>
<li>
<p>Útil para escenarios donde se necesita separar la orquestación del build de la ejecución, o para aprovechar hardware específico (por ejemplo, builds nativos para ARM en máquinas ARM).</p>
</li>
<li>
<p>Requiere configuración manual del daemon BuildKit y de los certificados de seguridad si es necesario.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Característica</th>
<th class="tableblock halign-left valign-top">docker</th>
<th class="tableblock halign-left valign-top">docker-container</th>
<th class="tableblock halign-left valign-top">kubernetes</th>
<th class="tableblock halign-left valign-top">remote</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simplicidad y uso inmediato</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">—</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">—</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">—</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Soporte multi-arquitectura</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limitado</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exportación avanzada de caché</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limitado</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuración personalizada de recursos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí (vía Kubernetes)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí (según configuración)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aparición automática en <code>docker images</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No (requiere <code>--load</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No (requiere <code>--load</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No (requiere <code>--load</code>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Cada driver está pensado para un caso de uso específico, desde la simplicidad local hasta la escalabilidad y personalización en entornos distribuidos o empresariales.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_instancias_de_builder">Gestión de Instancias de Builder</h3>
<div class="paragraph">
<p>Docker Buildx permite gestionar múltiples instancias de builder, cada una con su propia configuración, capacidades y contexto. Esto es fundamental para adaptarse a diferentes flujos de trabajo, arquitecturas y entornos de construcción.</p>
</div>
<div class="sect3">
<h4 id="_listar_builders_disponibles">Listar builders disponibles</h4>
<div class="paragraph">
<p>Para ver todas las instancias de builder y sus detalles, utiliza:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx ls</pre>
</div>
</div>
<div class="paragraph">
<p>El resultado muestra los nombres, drivers, estado, versión de BuildKit y las plataformas soportadas por cada builder. El builder actualmente seleccionado aparece marcado con un asterisco (<code>*</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_crear_un_nuevo_builder">Crear un nuevo builder</h4>
<div class="paragraph">
<p>Puedes crear una nueva instancia de builder con un nombre personalizado usando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx create --name &lt;nombre_builder&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por defecto, este comando usa el driver <code>docker-container</code>, que es el más flexible para builds avanzados y multiplataforma.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cambiar_de_builder">Cambiar de builder</h4>
<div class="paragraph">
<p>Para seleccionar el builder que quieres usar en tus operaciones de construcción:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx use &lt;nombre_builder&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Esto establece el builder como predeterminado para el contexto actual.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inspeccionar_un_builder">Inspeccionar un builder</h4>
<div class="paragraph">
<p>Para ver información detallada sobre un builder específico, incluyendo nodos, plataformas soportadas y configuración:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx inspect &lt;nombre_builder&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Puedes añadir la opción <code>--bootstrap</code> para asegurarte de que el builder está iniciado antes de inspeccionarlo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_eliminar_un_builder">Eliminar un builder</h4>
<div class="paragraph">
<p>Si ya no necesitas un builder, puedes eliminarlo con:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx rm &lt;nombre_builder&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Esto libera recursos y mantiene tu entorno organizado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_de_comandos_principales">Resumen de comandos principales</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comando</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descripción</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx ls</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lista todos los builders disponibles</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx create --name N</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crea una nueva instancia de builder</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx use N</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cambia al builder N como predeterminado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx inspect [N]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inspecciona el builder N o el actual</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx rm N</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elimina el builder N</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Esta gestión flexible de instancias de builder permite optimizar y personalizar los procesos de construcción en Docker Buildx, facilitando la adaptación a proyectos de distinta complejidad y requisitos de arquitectura.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uso_básico_de_buildx">Uso Básico de Buildx</h3>
<div class="paragraph">
<p>Docker Buildx es la herramienta recomendada para construir imágenes de contenedores modernas, permitiendo compilaciones multiplataforma, optimización de caché y procesamiento en paralelo, todo integrado en la CLI de Docker.</p>
</div>
<div class="sect3">
<h4 id="_comando_principal">Comando principal</h4>
<div class="paragraph">
<p>El comando base para iniciar una construcción es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx build [OPCIONES] RUTA_O_URL_DEL_CONTEXTO</pre>
</div>
</div>
<div class="paragraph">
<p>Por ejemplo, para construir una imagen desde el Dockerfile del directorio actual:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx build -t mi_aplicacion_web:1.0 .</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_opciones_más_comunes">Opciones más comunes</h4>
<div class="paragraph">
<p>Las opciones principales que puedes usar con <code>docker buildx build</code> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-t, --tag nombre:etiqueta</code>
Asigna un nombre y etiqueta a la imagen resultante.</p>
</li>
<li>
<p><code>-f, --file ruta_al_dockerfile</code>
Especifica el archivo Dockerfile a utilizar (por defecto busca <code>Dockerfile</code> en el contexto).</p>
</li>
<li>
<p><code>--platform plataforma[,plataforma&#8230;&#8203;]</code>
Define la(s) plataforma(s) objetivo, por ejemplo: <code>linux/amd64,linux/arm64</code>.</p>
</li>
<li>
<p><code>--push</code>
Publica la imagen directamente en un registro remoto tras la construcción.</p>
</li>
<li>
<p><code>--load</code>
Carga la imagen construida en el demonio Docker local (útil si usas el driver <code>docker-container</code>).</p>
</li>
<li>
<p><code>-o, --output tipo=destino</code>
Exporta el resultado a diferentes formatos o ubicaciones, como un directorio local, archivo tar, o registro.</p>
</li>
<li>
<p><code>--build-arg clave=valor</code>
Pasa variables de entorno al proceso de construcción.</p>
</li>
<li>
<p><code>--cache-from</code>, <code>--cache-to</code>
Gestiona fuentes y destinos de caché para acelerar builds y compartir resultados entre entornos.</p>
</li>
<li>
<p><code>--secret id=mi_secreto,src=/ruta/al/archivo</code>
Inyecta secretos de forma segura durante la construcción.</p>
</li>
<li>
<p><code>--ssh default</code>
Permite el uso de claves SSH en etapas que lo requieran.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplos_prácticos">Ejemplos prácticos</h4>
<div class="ulist">
<ul>
<li>
<p>Construir imagen básica:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build -t mi_app:latest .</pre>
</div>
</div>
</li>
<li>
<p>Construcción multiplataforma y push:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --platform linux/amd64,linux/arm64 -t usuario/mi_app:multiarch --push .</pre>
</div>
</div>
</li>
<li>
<p>Usar un Dockerfile específico y contexto personalizado:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build -f Dockerfile.prod -t mi_app:prod ./src</pre>
</div>
</div>
</li>
<li>
<p>Utilizar caché local para acelerar builds:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --cache-from type=local,src=./buildcache --cache-to type=local,dest=./buildcache -t mi_app:cache .</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_flujo_de_trabajo_resumido">Flujo de trabajo resumido</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Selecciona o crea un builder adecuado para tu proyecto.</p>
</li>
<li>
<p>Ejecuta <code>docker buildx build</code> con las opciones necesarias según tu flujo de trabajo.</p>
</li>
<li>
<p>Inspecciona los resultados y, si es necesario, publica o exporta la imagen.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_prácticos_2">Ejemplos Prácticos</h3>
<div class="paragraph">
<p>Docker Buildx permite construir imágenes de forma eficiente y flexible, tanto para desarrollos locales como para despliegues multiplataforma o integraciones en CI/CD. A continuación se muestran ejemplos prácticos de uso, desde lo más básico hasta flujos avanzados.</p>
</div>
<div class="sect3">
<h4 id="_construcción_básica_de_una_imagen">Construcción básica de una imagen</h4>
<div class="paragraph">
<p>Supón que tienes un proyecto Node.js con el siguiente Dockerfile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FROM node:14

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 8080

CMD ["node", "server.js"]</pre>
</div>
</div>
<div class="paragraph">
<p>Para construir la imagen usando Buildx:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx build -t my-node-app:latest .</pre>
</div>
</div>
<div class="paragraph">
<p>Esto genera una imagen etiquetada como <code>my-node-app:latest</code> usando el Dockerfile del directorio actual.</p>
</div>
</div>
<div class="sect3">
<h4 id="_construcción_multiplataforma">Construcción multiplataforma</h4>
<div class="paragraph">
<p>Si necesitas que tu imagen funcione tanto en arquitecturas amd64 como arm64 (por ejemplo, para servidores x86 y Raspberry Pi), puedes usar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --platform linux/amd64,linux/arm64 -t my-multi-platform-app:latest --push .</pre>
</div>
</div>
<div class="paragraph">
<p>Este comando construye la imagen para ambas arquitecturas y la sube directamente a un registro (por ejemplo, Docker Hub), permitiendo que cualquier máquina la descargue y ejecute sin importar su arquitectura.</p>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_compilaciones_multietapa_multi_stage_builds">Uso de compilaciones multietapa (multi-stage builds)</h4>
<div class="paragraph">
<p>Las compilaciones multietapa permiten optimizar el tamaño y la seguridad de las imágenes. Por ejemplo, para una aplicación Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre># Dockerfile.optimized

FROM python:3.13-slim AS base
WORKDIR /app
COPY requirements.txt .

FROM base AS builder
RUN pip install --no-cache-dir --target=/install -r requirements.txt

FROM base AS linter
COPY --from=builder /install /usr/local/lib/python3.13/site-packages
COPY app.py .
RUN pip install pylint &amp;&amp; pylint app.py || exit 0

FROM base AS tester
COPY --from=builder /install /usr/local/lib/python3.9/site-packages
COPY app.py .
RUN pip install pytest &amp;&amp; python -m pytest app.py -v || exit 0

FROM python:3.13-alpine AS final
WORKDIR /app
COPY --from=builder /install /usr/local/lib/python3.13/site-packages
COPY app.py .
EXPOSE 5000
CMD ["python", "app.py"]</pre>
</div>
</div>
<div class="paragraph">
<p>Construye la imagen optimizada así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --file Dockerfile.optimized -t myapp:optimized --load .</pre>
</div>
</div>
<div class="paragraph">
<p>Buildx ejecutará las etapas independientes (como <code>linter</code> y <code>tester</code>) en paralelo, acelerando el proceso y generando una imagen final más pequeña y eficiente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_caché_avanzada">Ejemplo de caché avanzada</h4>
<div class="paragraph">
<p>Para acelerar builds repetidos, puedes utilizar la caché local:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --cache-to type=local,dest=./buildcache -t myapp:latest .
docker buildx build --cache-from type=local,src=./buildcache -t myapp:latest .</pre>
</div>
</div>
<div class="paragraph">
<p>Esto permite reutilizar capas previas y reducir drásticamente los tiempos de compilación en desarrollos iterativos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_automatización_en_cicd">Automatización en CI/CD</h4>
<div class="paragraph">
<p>Buildx se integra fácilmente en pipelines de CI/CD. Por ejemplo, en GitHub Actions o Jenkins puedes crear el builder, construir la imagen multiplataforma y subirla a un registro en cada push:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx create --use
docker buildx build --platform linux/amd64,linux/arm64 -t usuario/app:ci --push .</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exportar_imágenes_en_diferentes_formatos">Exportar imágenes en diferentes formatos</h4>
<div class="paragraph">
<p>Puedes exportar el resultado a un archivo tar o a un directorio local, útil para pruebas o distribución fuera de un registro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --output type=tar,dest=miimagen.tar -t miapp:latest .
docker buildx build --output type=local,dest=./output -t miapp:latest .</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_funcionalidades_avanzadas">Funcionalidades Avanzadas</h3>
<div class="paragraph">
<p>Docker Buildx ofrece un conjunto de funcionalidades avanzadas que amplían y optimizan los flujos de trabajo de construcción de imágenes, especialmente en entornos complejos, distribuidos o de CI/CD. Estas capacidades van mucho más allá de lo que permite el comando clásico <code>docker build</code>.</p>
</div>
<div class="sect3">
<h4 id="_construcción_multiplataforma_y_cross_compilation">Construcción multiplataforma y cross-compilation</h4>
<div class="ulist">
<ul>
<li>
<p>Permite construir imágenes para varias arquitecturas (por ejemplo, <code>linux/amd64</code>, <code>linux/arm64</code>, etc.) en un solo comando, generando imágenes listas para ejecutarse en cualquier entorno objetivo.</p>
</li>
<li>
<p>Soporta la compilación cruzada (cross-compilation), permitiendo crear imágenes para arquitecturas distintas a la de la máquina host, ideal para IoT, edge computing o despliegues híbridos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_optimización_de_builds_multietapa_y_paralelismo">Optimización de builds multietapa y paralelismo</h4>
<div class="ulist">
<ul>
<li>
<p>Buildx aprovecha BuildKit para identificar etapas independientes en Dockerfiles multietapa y ejecutarlas en paralelo, acelerando significativamente la construcción y reduciendo el tiempo total de build.</p>
</li>
<li>
<p>Esta optimización es especialmente útil en proyectos con etapas de linting, testing y build desacopladas, donde las tareas pueden ejecutarse simultáneamente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exportadores_y_outputs_flexibles">Exportadores y outputs flexibles</h4>
<div class="ulist">
<ul>
<li>
<p>Buildx soporta múltiples tipos de exportadores para los resultados de la build, configurables mediante la opción <code>--output</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>image</code>: exporta la imagen al demonio Docker local.</p>
</li>
<li>
<p><code>registry</code>: sube la imagen directamente a un registro remoto.</p>
</li>
<li>
<p><code>local</code>: exporta el sistema de archivos raíz de la build a un directorio local.</p>
</li>
<li>
<p><code>tar</code>: empaqueta el sistema de archivos raíz en un archivo tar local.</p>
</li>
<li>
<p><code>oci</code>: exporta la imagen en formato OCI.</p>
</li>
<li>
<p><code>docker</code>: exporta la imagen en formato Docker Image Spec v1.2.0.</p>
</li>
<li>
<p><code>cacheonly</code>: ejecuta el build solo para generar caché, sin exportar una imagen.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --output type=tar,dest=miimagen.tar -t miapp:latest .</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_avanzada_de_caché">Gestión avanzada de caché</h4>
<div class="ulist">
<ul>
<li>
<p>Buildx permite exportar e importar caché de builds, tanto localmente como en registros remotos, acelerando builds repetidos y facilitando la colaboración en equipos distribuidos.</p>
</li>
<li>
<p>Ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --cache-to type=local,dest=./buildcache -t myapp:latest .
docker buildx build --cache-from type=local,src=./buildcache -t myapp:latest .</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_remota_y_builders_externos">Ejecución remota y builders externos</h4>
<div class="ulist">
<ul>
<li>
<p>Puedes ejecutar builds en builders remotos, servidores dedicados, clusters Kubernetes o servicios en la nube, liberando recursos locales y escalando la capacidad de construcción según la demanda.</p>
</li>
<li>
<p>Esto permite adaptar los flujos de trabajo a necesidades empresariales, builds masivos o integración con pipelines de CI/CD.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buildx_bake_orquestación_de_builds_complejos">buildx bake: orquestación de builds complejos</h4>
<div class="ulist">
<ul>
<li>
<p><code>docker buildx bake</code> permite definir y construir múltiples imágenes en paralelo desde un solo archivo de configuración (<code>docker-bake.hcl</code>, JSON o incluso archivos de Docker Compose).</p>
</li>
<li>
<p>Ideal para monorepos, microservicios o proyectos con múltiples imágenes y dependencias compartidas.</p>
</li>
<li>
<p>Ejemplo de archivo HCL:</p>
<div class="listingblock">
<div class="content">
<pre>group "default" {
  targets = ["app", "db", "cron"]
}

target "app" {
  dockerfile = "Dockerfile.app"
  platforms = ["linux/amd64", "linux/arm64"]
  tags = ["repo/app:test"]
}</pre>
</div>
</div>
</li>
<li>
<p>Ejecuta todos los targets en paralelo:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx bake</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buildx_imagetools_gestión_avanzada_de_imágenes_y_manifests">buildx imagetools: gestión avanzada de imágenes y manifests</h4>
<div class="ulist">
<ul>
<li>
<p>El subcomando <code>docker buildx imagetools</code> permite trabajar con manifest lists en registros de contenedores, inspeccionando y gestionando imágenes multiplataforma y sus configuraciones.</p>
</li>
<li>
<p>Ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx imagetools inspect usuario/imagen:tag</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buenas_prácticas_y_optimización">Buenas Prácticas y Optimización</h3>
<div class="paragraph">
<p>Aplicar buenas prácticas y técnicas de optimización al usar Docker Buildx es fundamental para obtener imágenes más pequeñas, builds más rápidos y flujos de trabajo predecibles y eficientes. A continuación se resumen las recomendaciones clave respaldadas por la experiencia y la documentación especializada:</p>
</div>
<div class="sect3">
<h4 id="_optimización_de_builds_multietapa_y_paralelismo_2">Optimización de builds multietapa y paralelismo</h4>
<div class="ulist">
<ul>
<li>
<p>Utiliza compilaciones multietapa para reducir el tamaño de la imagen final, separando las fases de construcción, pruebas, linting y empaquetado. Solo copia al resultado final lo estrictamente necesario.</p>
</li>
<li>
<p>Buildx permite que etapas independientes se ejecuten en paralelo, acelerando significativamente el proceso de construcción frente al builder clásico. Por ejemplo, las etapas de <code>linter</code> y <code>tester</code> pueden correr simultáneamente si no dependen entre sí.</p>
</li>
<li>
<p>Ejemplo de build multietapa optimizada:</p>
<div class="listingblock">
<div class="content">
<pre>docker buildx build --file Dockerfile.optimized -t myapp:optimized --load .</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_aprovecha_la_caché_avanzada">Aprovecha la caché avanzada</h4>
<div class="ulist">
<ul>
<li>
<p>Usa las opciones <code>--cache-from</code> y <code>--cache-to</code> para reutilizar capas previas y compartir caché entre diferentes builds o entornos, acelerando reconstrucciones y ahorrando recursos.</p>
</li>
<li>
<p>Ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre># Primera build: crea la caché
docker buildx build --load -t myapp:latest --cache-to type=local,dest=./buildcache .

# Builds posteriores: reutiliza la caché
docker buildx build --load -t myapp:latest --cache-from type=local,src=./buildcache .</pre>
</div>
</div>
</li>
<li>
<p>Ordena las instrucciones del Dockerfile de lo más estable a lo más cambiante para maximizar el aprovechamiento de la caché.</p>
</li>
<li>
<p>Utiliza <code>--mount=type=cache</code> en etapas que descargan dependencias o generan archivos temporales, para mantener estos directorios entre builds.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_minimiza_el_contexto_de_build">Minimiza el contexto de build</h4>
<div class="ulist">
<ul>
<li>
<p>Usa un archivo <code>.dockerignore</code> bien definido para excluir archivos y carpetas innecesarias del contexto de build (por ejemplo: <code>.git</code>, <code>node_modules</code>, archivos temporales, etc.), lo que reduce el tamaño del contexto y acelera la transferencia y el análisis.</p>
<div class="listingblock">
<div class="content">
<pre># Ejemplo de .dockerignore
.git
node_modules
__pycache__
*.pyc
*.pyo
.DS_Store</pre>
</div>
</div>
</li>
<li>
<p>Esto evita que archivos irrelevantes se copien a la imagen y que la caché se invalide por cambios frecuentes en archivos no esenciales.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_mantén_el_dockerfile_simple_y_eficiente">Mantén el Dockerfile simple y eficiente</h4>
<div class="ulist">
<ul>
<li>
<p>Minimiza el número de capas combinando comandos en una sola instrucción <code>RUN</code> cuando sea posible.</p>
</li>
<li>
<p>Limpia archivos temporales y cachés de paquetes tras la instalación para reducir el tamaño final de la imagen.</p>
</li>
<li>
<p>Coloca las instrucciones que cambian menos al principio del Dockerfile y las más volátiles (como <code>COPY . .</code>) al final, para aprovechar mejor la caché de capas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_usa_etiquetas_y_versiones_explícitas">Usa etiquetas y versiones explícitas</h4>
<div class="ulist">
<ul>
<li>
<p>Etiqueta tus imágenes con versiones o tags significativos para evitar confusiones y facilitar la trazabilidad en despliegues y entornos de CI/CD.</p>
</li>
<li>
<p>Evita utilizar solo <code>latest</code> salvo en entornos de desarrollo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_seguridad_y_secretos">Seguridad y secretos</h4>
<div class="ulist">
<ul>
<li>
<p>Usa el soporte de secretos de Buildx (<code>--secret</code>) para inyectar credenciales o claves de forma segura durante la build, evitando que queden expuestas en las capas de la imagen.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_medición_y_comparación_de_builds">Medición y comparación de builds</h4>
<div class="ulist">
<ul>
<li>
<p>Mide los tiempos de construcción y el tamaño de las imágenes para validar las mejoras introducidas:</p>
<div class="listingblock">
<div class="content">
<pre>time docker buildx build --load -t myapp:parallel -f Dockerfile.parallel .
docker images myapp</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_recursos_y_documentación_para_buildx">Recursos y documentación para buildx</h3>
<div class="paragraph">
<p>Contar con recursos oficiales y comunitarios es fundamental para dominar Docker Buildx y aprovechar todas sus capacidades avanzadas. A continuación se listan las principales fuentes de información y soporte técnico actualizadas a 2025:</p>
</div>
<div class="sect3">
<h4 id="_documentación_oficial_de_docker_buildx">Documentación oficial de Docker Buildx</h4>
<div class="ulist">
<ul>
<li>
<p>Referencia de comandos y opciones:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.docker.com/reference/cli/docker/buildx/" class="bare">https://docs.docker.com/reference/cli/docker/buildx/</a></p>
</li>
<li>
<p><a href="https://docs.docker.com/reference/cli/docker/buildx/build/" class="bare">https://docs.docker.com/reference/cli/docker/buildx/build/</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Conceptos y arquitectura:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.docker.com/build/concepts/overview/" class="bare">https://docs.docker.com/build/concepts/overview/</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Guía de trabajo con Buildx:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docker-docs.uclv.cu/buildx/working-with-buildx/" class="bare">https://docker-docs.uclv.cu/buildx/working-with-buildx/</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_repositorio_oficial_en_github">Repositorio oficial en GitHub</h4>
<div class="ulist">
<ul>
<li>
<p>Código fuente, releases, issues y documentación técnica avanzada:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/docker/buildx" class="bare">https://github.com/docker/buildx</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplos de instalación manual, uso en Dockerfile y automatización en CI/CD.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_comunidad_docker">Comunidad Docker</h4>
<div class="ulist">
<ul>
<li>
<p>Foros, blogs, tutoriales y contribuciones de expertos (Docker Captains):</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.docker.com/community/" class="bare">https://www.docker.com/community/</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplos de integración con GitHub Actions, publicación de imágenes multi-arch, buenas prácticas y casos de uso reales.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_subcomandos_y_utilidades_clave">Subcomandos y utilidades clave</h4>
<div class="paragraph">
<p>Buildx incluye subcomandos útiles para gestionar builders, caché, imágenes y flujos avanzados:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comando</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descripción</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx build</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inicia una build con BuildKit</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crea una nueva instancia de builder</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx ls</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lista builders disponibles</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx use</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Selecciona el builder activo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx inspect</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Muestra detalles del builder</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx rm</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elimina builders</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx bake</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Orquesta builds desde archivos de configuración</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx imagetools</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gestiona y consulta imágenes y manifests multi-arch</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx prune</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limpia caché de builds</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker buildx version</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Muestra la versión de buildx instalada</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_instalación_y_actualización">Instalación y actualización</h4>
<div class="ulist">
<ul>
<li>
<p>Buildx viene incluido por defecto en Docker Desktop (Windows/macOS) y en los paquetes oficiales de Docker Engine para Linux.</p>
</li>
<li>
<p>Para instalaciones manuales o actualizaciones específicas, consulta el repositorio de GitHub y sigue las instrucciones para tu sistema operativo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_consejos_para_profundizar">Consejos para profundizar</h4>
<div class="ulist">
<ul>
<li>
<p>Consulta los ejemplos y tutoriales de la comunidad para casos prácticos y automatización en CI/CD (por ejemplo, integración con GitHub Actions o Jenkins).</p>
</li>
<li>
<p>Participa en foros y canales oficiales para resolver dudas y compartir experiencias con otros usuarios avanzados.</p>
</li>
<li>
<p>Revisa periódicamente las notas de versión y la hoja de ruta pública para estar al día de nuevas funcionalidades y mejoras.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_docker_compose">Docker Compose</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Docker Compose es una herramienta que permite definir, configurar y gestionar aplicaciones multicontenedor de manera sencilla y declarativa, utilizando archivos YAML. Es ideal para entornos de desarrollo, pruebas y despliegues donde se requieren varios servicios (por ejemplo, una aplicación web, una base de datos y un sistema de caché) que deben funcionar juntos.</p>
</div>
<div class="sect2">
<h3 id="_introducción_a_docker_compose">Introducción a Docker Compose</h3>
<div class="paragraph">
<p>Docker Compose es una herramienta que permite definir, configurar y gestionar aplicaciones multicontenedor de forma sencilla y declarativa mediante archivos YAML. Es especialmente útil cuando una aplicación requiere varios servicios (por ejemplo, una web, una base de datos y un sistema de caché) que deben funcionar juntos y comunicarse entre sí.</p>
</div>
<div class="sect3">
<h4 id="_ventajas_de_docker_compose">Ventajas de Docker Compose</h4>
<div class="ulist">
<ul>
<li>
<p>Permite definir toda la arquitectura de la aplicación en un solo archivo (<code>docker-compose.yml</code>).</p>
</li>
<li>
<p>Facilita la reproducción de entornos en diferentes máquinas y equipos.</p>
</li>
<li>
<p>Automatiza la creación de redes, volúmenes y dependencias entre servicios.</p>
</li>
<li>
<p>Simplifica la gestión del ciclo de vida de aplicaciones multicontenedor con comandos simples.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_cómo_funciona">¿Cómo funciona?</h4>
<div class="paragraph">
<p>Compose utiliza un archivo YAML donde se describen los servicios, redes y volúmenes necesarios. Con comandos como <code>docker-compose up</code> y <code>docker-compose down</code>, puedes levantar o detener toda la aplicación de manera sencilla.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_archivo_docker_compose_yml">Ejemplo básico de archivo docker-compose.yml</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: "3.9"
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
  db:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: ejemplo
    volumes:
      - datos_mysql:/var/lib/mysql

volumes:
  datos_mysql:</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo:
- Se definen dos servicios: <code>web</code> (nginx) y <code>db</code> (MySQL).
- Se mapea el puerto 8080 del host al 80 del contenedor nginx.
- Se crea un volumen persistente para los datos de la base de datos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_comandos_principales_de_docker_compose">Comandos principales de Docker Compose</h4>
<div class="ulist">
<ul>
<li>
<p><code>docker-compose up -d</code>: Levanta todos los servicios en segundo plano.</p>
</li>
<li>
<p><code>docker-compose down</code>: Detiene y elimina los contenedores, redes y volúmenes creados.</p>
</li>
<li>
<p><code>docker-compose ps</code>: Lista los servicios en ejecución.</p>
</li>
<li>
<p><code>docker-compose logs</code>: Muestra los logs de todos los servicios.</p>
</li>
<li>
<p><code>docker-compose exec &lt;servicio&gt; &lt;comando&gt;</code>: Ejecuta un comando en un contenedor de un servicio.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_9">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Mantén el archivo <code>docker-compose.yml</code> bajo control de versiones.</p>
</li>
<li>
<p>Usa variables de entorno para parametrizar configuraciones sensibles o cambiantes.</p>
</li>
<li>
<p>Define volúmenes para persistir datos importantes.</p>
</li>
<li>
<p>Documenta la función de cada servicio y volumen en el archivo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_del_archivo_docker_compose_yml">Estructura del archivo docker-compose.yml</h3>
<div class="paragraph">
<p>El archivo <code>docker-compose.yml</code> es el núcleo de Docker Compose y define, de manera declarativa, todos los servicios, redes y volúmenes que forman una aplicación multicontenedor. Su sintaxis está basada en YAML y es fácil de leer y mantener.</p>
</div>
<div class="sect3">
<h4 id="_secciones_principales_del_archivo">Secciones principales del archivo</h4>
<div class="ulist">
<ul>
<li>
<p><code>version</code>: Especifica la versión del esquema de Compose (por ejemplo, <code>"3.9"</code>).</p>
</li>
<li>
<p><code>services</code>: Define los contenedores (servicios) que componen la aplicación.</p>
</li>
<li>
<p><code>volumes</code>: Declara volúmenes persistentes que pueden ser usados por los servicios.</p>
</li>
<li>
<p><code>networks</code>: (Opcional) Define redes personalizadas para aislar o conectar servicios.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_estructura">Ejemplo básico de estructura</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: "3.9"
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    networks:
      - red_interna
  db:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: ejemplo
    volumes:
      - datos_mysql:/var/lib/mysql
    networks:
      - red_interna

volumes:
  datos_mysql:

networks:
  red_interna:</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_explicación_de_los_elementos">Explicación de los elementos</h4>
<div class="ulist">
<ul>
<li>
<p><strong>services</strong>: Cada clave bajo <code>services</code> representa un servicio (contenedor). Puedes definir su imagen, build, variables de entorno, puertos, volúmenes, dependencias, etc.</p>
</li>
<li>
<p><strong>volumes</strong>: Permite declarar volúmenes persistentes que pueden ser compartidos entre servicios.</p>
</li>
<li>
<p><strong>networks</strong>: Define redes personalizadas para controlar la comunicación entre servicios.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_opciones_comunes_en_servicios">Opciones comunes en servicios</h4>
<div class="ulist">
<ul>
<li>
<p><code>build</code>: Ruta al Dockerfile para construir la imagen localmente.</p>
</li>
<li>
<p><code>image</code>: Imagen a usar (puede ser de Docker Hub o personalizada).</p>
</li>
<li>
<p><code>ports</code>: Lista de puertos a mapear (<code>host:contenedor</code>).</p>
</li>
<li>
<p><code>environment</code>: Variables de entorno.</p>
</li>
<li>
<p><code>volumes</code>: Montajes de volúmenes o bind mounts.</p>
</li>
<li>
<p><code>depends_on</code>: Define dependencias de arranque entre servicios.</p>
</li>
<li>
<p><code>command</code>: Comando a ejecutar al iniciar el contenedor.</p>
</li>
<li>
<p><code>restart</code>: Política de reinicio (<code>always</code>, <code>on-failure</code>, etc.).</p>
</li>
<li>
<p><code>networks</code>: Redes a las que se conecta el servicio.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_avanzado">Ejemplo avanzado</h4>
<div class="listingblock">
<div class="title">Este ejemplo muestra una aplicación web con Flask y PostgreSQL, donde se definen dos servicios (<code>app</code> y <code>db</code>), un volumen para la base de datos y una red personalizada.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: "3.9"
services:
  app:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=development
    volumes:
      - .:/app
    depends_on:
      - db
    networks:
      - backend
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: ejemplo
    volumes:
      - datos_pg:/var/lib/postgresql/data
    networks:
      - backend

volumes:
  datos_pg:

networks:
  backend:</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_10">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa nombres descriptivos para servicios, volúmenes y redes.</p>
</li>
<li>
<p>Mantén el archivo indentado correctamente (YAML es sensible a la indentación).</p>
</li>
<li>
<p>Documenta cada sección con comentarios si es necesario.</p>
</li>
<li>
<p>Separa configuraciones de desarrollo y producción usando archivos adicionales o variables de entorno.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_definición_de_servicios_redes_y_volúmenes">Definición de servicios, redes y volúmenes</h3>
<div class="paragraph">
<p>En Docker Compose, la definición de servicios, redes y volúmenes en el archivo <code>docker-compose.yml</code> permite describir de forma declarativa toda la arquitectura de una aplicación multicontenedor. A continuación se explica cada uno de estos elementos con ejemplos y buenas prácticas.</p>
</div>
<div class="sect3">
<h4 id="_servicios">Servicios</h4>
<div class="paragraph">
<p>Un servicio representa un contenedor o grupo de contenedores idénticos que ejecutan una parte de la aplicación (por ejemplo, una web, una base de datos, un sistema de caché).</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de definición de servicios:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    depends_on:
      - db
    networks:
      - backend
  db:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: ejemplo
    volumes:
      - datos_mysql:/var/lib/mysql
    networks:
      - backend</code></pre>
</div>
</div>
<div class="ulist">
<div class="title"><strong>Opciones comunes en servicios:</strong></div>
<ul>
<li>
<p><code>image</code>: Imagen a usar para el servicio.</p>
</li>
<li>
<p><code>build</code>: Ruta al Dockerfile si se construye la imagen localmente.</p>
</li>
<li>
<p><code>ports</code>: Mapeo de puertos entre host y contenedor.</p>
</li>
<li>
<p><code>environment</code>: Variables de entorno.</p>
</li>
<li>
<p><code>volumes</code>: Montaje de volúmenes o bind mounts.</p>
</li>
<li>
<p><code>depends_on</code>: Define dependencias de arranque entre servicios.</p>
</li>
<li>
<p><code>networks</code>: Redes a las que se conecta el servicio.</p>
</li>
<li>
<p><code>command</code>, <code>restart</code>, <code>healthcheck</code>, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_volúmenes">Volúmenes</h4>
<div class="paragraph">
<p>Los volúmenes permiten persistir datos y compartirlos entre servicios. Se definen en la sección <code>volumes</code> y luego se referencian en los servicios.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de definición de volúmenes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">volumes:
  datos_mysql:
  datos_pg:</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Uso en servicios:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">services:
  db:
    image: postgres:15
    volumes:
      - datos_pg:/var/lib/postgresql/data</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_redes">Redes</h4>
<div class="paragraph">
<p>Las redes permiten aislar y controlar la comunicación entre servicios. Compose crea una red por defecto, pero puedes definir redes personalizadas para mayor control.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de definición de redes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">networks:
  backend:
  frontend:</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Asignación de redes a servicios:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">services:
  web:
    image: nginx:alpine
    networks:
      - frontend
      - backend
  db:
    image: mysql:8
    networks:
      - backend</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_completo_de_docker_compose_yml">Ejemplo completo de docker-compose.yml</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: "3.9"
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    networks:
      - frontend
      - backend
  app:
    build: .
    depends_on:
      - db
    networks:
      - backend
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: ejemplo
    volumes:
      - datos_pg:/var/lib/postgresql/data
    networks:
      - backend

volumes:
  datos_pg:

networks:
  frontend:
  backend:</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_11">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa nombres descriptivos para servicios, redes y volúmenes.</p>
</li>
<li>
<p>Separa redes internas (backend) y externas (frontend) para mayor seguridad.</p>
</li>
<li>
<p>Define volúmenes para persistir datos críticos.</p>
</li>
<li>
<p>Utiliza <code>depends_on</code> para controlar el orden de arranque de los servicios.</p>
</li>
<li>
<p>Documenta la función de cada elemento en el archivo YAML.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_del_ciclo_de_vida_de_aplicaciones_multi_contenedor">Gestión del ciclo de vida de aplicaciones multi-contenedor</h3>
<div class="paragraph">
<p>La gestión del ciclo de vida de aplicaciones multi-contenedor implica controlar de manera eficiente el despliegue, actualización, monitoreo y eliminación de todos los servicios que forman parte de una solución definida con Docker Compose. A continuación se explican los aspectos clave y comandos esenciales para administrar aplicaciones multicontenedor.</p>
</div>
<div class="sect3">
<h4 id="_arranque_y_parada_de_la_aplicación">Arranque y parada de la aplicación</h4>
<div class="listingblock">
<div class="title"><strong>Levantar todos los servicios</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose up -d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto crea y arranca todos los contenedores definidos en el archivo <code>docker-compose.yml</code> en segundo plano.</p>
</div>
<div class="listingblock">
<div class="title"><strong>Detener y eliminar servicios, redes y volúmenes</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose down</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Por defecto, elimina los contenedores y redes creados. Para eliminar también los volúmenes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose down -v</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_escalado_de_servicios">Escalado de servicios</h4>
<div class="listingblock">
<div class="title">Puedes escalar un servicio para ejecutar múltiples instancias (réplicas) del mismo contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose up -d --scale web=3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto ejecuta tres instancias del servicio <code>web</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_actualización_y_recreación_de_servicios">Actualización y recreación de servicios</h4>
<div class="listingblock">
<div class="title"><strong>Reconstruir imágenes y recrear contenedores</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose up -d --build</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Recrear un solo servicio</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose up -d --no-deps --build web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_monitorización_y_logs">Monitorización y logs</h4>
<div class="listingblock">
<div class="title"><strong>Ver el estado de los servicios</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose ps</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Ver logs de todos los servicios o de uno específico</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose logs
docker-compose logs db</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Acceder a un contenedor en ejecución</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose exec web bash</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parada_reinicio_y_eliminación_selectiva">Parada, reinicio y eliminación selectiva</h4>
<div class="listingblock">
<div class="title"><strong>Detener todos los servicios sin eliminar recursos</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose stop</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Reiniciar servicios</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose restart</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Eliminar solo los contenedores (manteniendo redes y volúmenes)</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose rm</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_actualización_de_la_configuración">Actualización de la configuración</h4>
<div class="listingblock">
<div class="title">Si modificas el archivo <code>docker-compose.yml</code>, puedes aplicar los cambios con:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose up -d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Compose detectará los cambios y recreará solo los servicios afectados.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_12">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Mantén el archivo <code>docker-compose.yml</code> bajo control de versiones.</p>
</li>
<li>
<p>Usa variables de entorno para parametrizar configuraciones sensibles.</p>
</li>
<li>
<p>Realiza backups periódicos de los volúmenes de datos.</p>
</li>
<li>
<p>Documenta los comandos y procedimientos habituales para tu equipo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_entornos_de_desarrollo_vs_producción">Entornos de desarrollo vs. producción</h3>
<div class="paragraph">
<p>El uso de Docker en entornos de desarrollo y producción presenta diferencias clave en cuanto a configuración, seguridad, persistencia y gestión de recursos. Entender estas diferencias es fundamental para diseñar flujos de trabajo eficientes y seguros.</p>
</div>
<div class="sect3">
<h4 id="_objetivos_y_prioridades">Objetivos y prioridades</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Desarrollo</strong>: Flexibilidad, rapidez en los cambios, facilidad de depuración y pruebas, integración con herramientas locales.</p>
</li>
<li>
<p><strong>Producción</strong>: Estabilidad, seguridad, rendimiento, escalabilidad, alta disponibilidad y recuperación ante fallos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_servicios">Configuración de servicios</h4>
<div class="ulist">
<ul>
<li>
<p>En desarrollo, es común usar archivos <code>docker-compose.yml</code> con montajes de código fuente (<code>bind mounts</code>) para reflejar cambios instantáneamente.</p>
</li>
<li>
<p>En producción, se recomienda usar imágenes inmutables y volúmenes gestionados por Docker para datos persistentes, evitando bind mounts directos del host.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de diferencia en volúmenes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Desarrollo
volumes:
  - .:/app  # Bind mount del código fuente

# Producción
volumes:
  - datos_app:/app  # Volumen gestionado por Docker</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_variables_de_entorno_y_secretos">Variables de entorno y secretos</h4>
<div class="ulist">
<ul>
<li>
<p>En desarrollo, las variables suelen almacenarse en archivos <code>.env</code> o directamente en el compose.</p>
</li>
<li>
<p>En producción, utiliza gestores de secretos (Docker Secrets, Vault, AWS Secrets Manager) y evita exponer credenciales en archivos o imágenes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_seguridad">Seguridad</h4>
<div class="ulist">
<ul>
<li>
<p>En desarrollo, puede ser aceptable ejecutar contenedores como root o exponer puertos ampliamente.</p>
</li>
<li>
<p>En producción, ejecuta servicios con usuarios no privilegiados, limita los puertos expuestos y aplica políticas de red y recursos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_escalabilidad_y_orquestación">Escalabilidad y orquestación</h4>
<div class="ulist">
<ul>
<li>
<p>En desarrollo, Compose es suficiente para levantar varios servicios en un solo host.</p>
</li>
<li>
<p>En producción, considera orquestadores como Docker Swarm o Kubernetes para gestionar múltiples instancias, balanceo de carga y alta disponibilidad.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_monitorización_y_logging">Monitorización y logging</h4>
<div class="ulist">
<ul>
<li>
<p>En desarrollo, los logs pueden verse con <code>docker logs</code> o <code>docker-compose logs</code>.</p>
</li>
<li>
<p>En producción, integra soluciones de logging centralizado (ELK, Loki, Fluentd) y monitorización (Prometheus, Grafana).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actualización_y_despliegue">Actualización y despliegue</h4>
<div class="ulist">
<ul>
<li>
<p>En desarrollo, los cambios son frecuentes y los contenedores se recrean a menudo.</p>
</li>
<li>
<p>En producción, usa despliegues controlados (rolling updates, blue/green deployments) y versiona las imágenes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_13">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Mantén archivos de configuración separados para desarrollo y producción (<code>docker-compose.override.yml</code>, variables de entorno, etc.).</p>
</li>
<li>
<p>Documenta las diferencias y requisitos de cada entorno.</p>
</li>
<li>
<p>Automatiza pruebas y despliegues para reducir errores humanos.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_docker_swarm_mode">Docker Swarm mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Docker Swarm es la herramienta de orquestación nativa de Docker que permite gestionar clústeres de contenedores de manera sencilla y eficiente. Proporciona funcionalidades como el balanceo de carga, la alta disponibilidad y la escalabilidad automática, facilitando la implementación y gestión de aplicaciones distribuidas.</p>
</div>
<div class="paragraph">
<p>Aunque Kubernetes se ha convertido en la herramienta de orquestación más popular y ampliamente adoptada, Docker Swarm mode sigue siendo utilizado en producción por muchas organizaciones que buscan una solución más sencilla y ligera.</p>
</div>
<div class="sect2">
<h3 id="_introducción_a_docker_swarm">Introducción a Docker Swarm</h3>
<div class="paragraph">
<p>Docker Swarm es la solución de orquestación nativa de Docker para gestionar clústeres de contenedores de forma sencilla, escalable y altamente disponible. Permite agrupar varios hosts Docker en un clúster (llamado "Swarm") y desplegar aplicaciones distribuidas como servicios, facilitando la administración, el escalado y la tolerancia a fallos.</p>
</div>
<div class="sect3">
<h4 id="_características_principales_de_docker_swarm">Características principales de Docker Swarm</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Orquestación nativa</strong>: Integrado en Docker Engine, sin necesidad de herramientas externas.</p>
</li>
<li>
<p><strong>Alta disponibilidad</strong>: Los servicios pueden ejecutarse en múltiples nodos, con replicación y failover automático.</p>
</li>
<li>
<p><strong>Escalabilidad</strong>: Permite escalar servicios fácilmente con un solo comando.</p>
</li>
<li>
<p><strong>Balanceo de carga</strong>: Distribuye el tráfico entre las réplicas de los servicios.</p>
</li>
<li>
<p><strong>Despliegue declarativo</strong>: Define el estado deseado de los servicios y Swarm se encarga de mantenerlo.</p>
</li>
<li>
<p><strong>Seguridad</strong>: Comunicación cifrada entre nodos y gestión de secretos integrada.</p>
</li>
<li>
<p><strong>Rolling updates y rollbacks</strong>: Actualizaciones controladas y reversión automática en caso de fallo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_cuándo_usar_docker_swarm">¿Cuándo usar Docker Swarm?</h4>
<div class="ulist">
<ul>
<li>
<p>Cuando necesitas desplegar aplicaciones en varios servidores de forma sencilla.</p>
</li>
<li>
<p>Para proyectos que requieren alta disponibilidad y balanceo de carga sin la complejidad de Kubernetes.</p>
</li>
<li>
<p>En entornos donde ya se utiliza Docker y se busca una solución de orquestación ligera y fácil de aprender.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_conceptos_clave">Conceptos clave</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Nodo</strong>: Cada máquina (física o virtual) que forma parte del clúster Swarm.</p>
</li>
<li>
<p><strong>Manager</strong>: Nodo que gestiona el clúster y toma decisiones de orquestación.</p>
</li>
<li>
<p><strong>Worker</strong>: Nodo que ejecuta tareas asignadas por los managers.</p>
</li>
<li>
<p><strong>Servicio</strong>: Definición de una aplicación o microservicio que se ejecuta en el clúster, compuesto por una o más réplicas (tareas).</p>
</li>
<li>
<p><strong>Tarea</strong>: Instancia individual de un contenedor gestionado por Swarm.</p>
</li>
<li>
<p><strong>Overlay network</strong>: Red virtual que conecta servicios en diferentes nodos del clúster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_flujo_básico_con_docker_swarm">Ejemplo de flujo básico con Docker Swarm</h4>
<div class="listingblock">
<div class="title">Inicializar el clúster Swarm en el nodo principal:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker swarm init</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Añadir nodos workers (el comando se muestra tras el init):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker swarm join --token &lt;token&gt; &lt;ip_manager&gt;:2377</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Desplegar un servicio replicado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service create --name web --replicas 3 -p 80:80 nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver el estado del clúster y los servicios:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker node ls
docker service ls
docker service ps web</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuración_de_un_clúster_swarm">Configuración de un clúster Swarm</h3>
<div class="paragraph">
<p>Configurar un clúster Docker Swarm te permite desplegar y gestionar aplicaciones distribuidas en varios hosts de forma sencilla y eficiente. A continuación se explica el proceso paso a paso, con ejemplos y buenas prácticas.</p>
</div>
<div class="sect3">
<h4 id="_requisitos_previos">Requisitos previos</h4>
<div class="ulist">
<ul>
<li>
<p>Tener Docker instalado en todos los nodos (máquinas físicas o virtuales) que formarán parte del clúster.</p>
</li>
<li>
<p>Conectividad de red entre los nodos (puertos 2377, 7946 y 4789 abiertos entre ellos).</p>
</li>
<li>
<p>Permisos de administrador (root o usuario en el grupo docker).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_inicializar_el_clúster_swarm">Inicializar el clúster Swarm</h4>
<div class="listingblock">
<div class="title">En el nodo que será el <strong>manager</strong> principal, ejecuta:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker swarm init --advertise-addr &lt;IP_MANAGER&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;IP_MANAGER&gt;</code> es la IP del nodo manager accesible por los demás nodos.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">El comando mostrará una línea similar a:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker swarm join --token SWMTKN-1-xxxx &lt;IP_MANAGER&gt;:2377</code></pre>
</div>
</div>
<div class="paragraph">
<p>Guarda este comando, lo necesitarás para unir los nodos workers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_añadir_nodos_workers_al_clúster">Añadir nodos workers al clúster</h4>
<div class="listingblock">
<div class="title">En cada nodo worker, ejecuta el comando <code>docker swarm join</code> proporcionado por el manager:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker swarm join --token &lt;TOKEN&gt; &lt;IP_MANAGER&gt;:2377</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;TOKEN&gt;</code> es el token de autenticación generado por el manager.
.Puedes obtener el token en cualquier momento con:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>docker swarm join-token worker</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_verificar_el_estado_del_clúster">Verificar el estado del clúster</h4>
<div class="listingblock">
<div class="title">En el nodo manager, revisa los nodos conectados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker node ls</code></pre>
</div>
</div>
<div class="paragraph">
<p>Verás una lista de nodos con su rol (Manager/Worker) y estado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_añadir_nodos_manager_adicionales_alta_disponibilidad">Añadir nodos manager adicionales (alta disponibilidad)</h4>
<div class="listingblock">
<div class="title">Para mayor tolerancia a fallos, puedes promover otros nodos a manager:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker swarm join-token manager
# Ejecuta el comando resultante en el nuevo nodo manager</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para promover un nodo existente a manager:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker node promote &lt;NOMBRE_O_ID_DEL_NODO&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_redes_overlay">Configuración de redes overlay</h4>
<div class="paragraph">
<p>Swarm crea automáticamente una red overlay llamada <code>ingress</code> para el balanceo de carga.</p>
</div>
<div class="listingblock">
<div class="title">Puedes crear redes overlay personalizadas para aislar servicios:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create --driver overlay mi_red_overlay</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_14">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa al menos 3 nodos manager para alta disponibilidad.</p>
</li>
<li>
<p>Mantén los tokens de join seguros; cámbialos si sospechas de un acceso no autorizado.</p>
</li>
<li>
<p>Supervisa el estado de los nodos y reemplaza los que fallen.</p>
</li>
<li>
<p>Documenta la topología y configuración del clúster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_del_flujo_de_configuración">Resumen del flujo de configuración</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Instala Docker en todos los nodos.</p>
</li>
<li>
<p>Inicializa el Swarm en el manager.</p>
</li>
<li>
<p>Une los workers con el token.</p>
</li>
<li>
<p>Verifica el clúster y promueve managers si es necesario.</p>
</li>
<li>
<p>Crea redes overlay para tus servicios.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Con estos pasos, tendrás un clúster Docker Swarm listo para desplegar servicios distribuidos, escalables y tolerantes a fallos.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_servicios_y_tareas">Gestión de servicios y tareas</h3>
<div class="paragraph">
<p>En Docker Swarm, los servicios y tareas son los elementos fundamentales para desplegar y gestionar aplicaciones distribuidas. Comprender cómo funcionan y cómo administrarlos es clave para sacar el máximo provecho de la orquestación nativa de Docker.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_un_servicio_en_swarm">¿Qué es un servicio en Swarm?</h4>
<div class="paragraph">
<p>Un servicio es una definición declarativa de cómo debe ejecutarse una aplicación o microservicio en el clúster. Incluye la imagen, el número de réplicas, los puertos expuestos, variables de entorno, redes y volúmenes asociados.</p>
</div>
<div class="listingblock">
<div class="title">Crear un servicio:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service create --name web --replicas 3 -p 80:80 nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto crea un servicio llamado <code>web</code> con 3 réplicas del contenedor nginx, balanceadas automáticamente entre los nodos del clúster.</p>
</div>
</div>
<div class="sect3">
<h4 id="_qué_es_una_tarea">¿Qué es una tarea?</h4>
<div class="paragraph">
<p>Una tarea es una instancia concreta de un contenedor gestionado por Swarm. Cada réplica de un servicio corresponde a una tarea, y Swarm se encarga de distribuirlas, reiniciarlas si fallan y mantener el estado deseado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_comandos_esenciales_para_la_gestión">Comandos esenciales para la gestión</h4>
<div class="listingblock">
<div class="title"><strong>Listar servicios activos:</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service ls</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Ver detalles y estado de las tareas de un servicio:</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service ps web</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Escalar un servicio (cambiar el número de réplicas):</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service scale web=5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Actualizar la imagen o configuración de un servicio:</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service update --image nginx:alpine web</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Eliminar un servicio:</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service rm web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inspección_y_control_avanzado">Inspección y control avanzado</h4>
<div class="listingblock">
<div class="title"><strong>Ver detalles completos de un servicio:</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service inspect web</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Ver logs de un servicio:</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service logs web</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Forzar el reinicio de todas las tareas de un servicio:</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service update --force web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_15">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Define servicios con el número adecuado de réplicas para garantizar alta disponibilidad.</p>
</li>
<li>
<p>Usa políticas de actualización y reinicio para minimizar el downtime.</p>
</li>
<li>
<p>Supervisa el estado de las tareas y automatiza alertas ante fallos.</p>
</li>
<li>
<p>Documenta la configuración de cada servicio y su propósito en el clúster.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_escalado_y_balanceo_de_carga">Escalado y balanceo de carga</h3>
<div class="paragraph">
<p>El escalado y el balanceo de carga son dos de las principales ventajas de usar Docker Swarm para aplicaciones distribuidas. Permiten aumentar la capacidad de procesamiento y garantizar alta disponibilidad de los servicios, distribuyendo el tráfico de manera eficiente entre múltiples instancias.</p>
</div>
<div class="sect3">
<h4 id="_escalado_de_servicios_2">Escalado de servicios</h4>
<div class="paragraph">
<p>Docker Swarm permite escalar cualquier servicio de forma sencilla, aumentando o disminuyendo el número de réplicas (instancias de contenedores) que ejecutan ese servicio.</p>
</div>
<div class="listingblock">
<div class="title">Escalar un servicio a 5 réplicas:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service scale web=5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">También puedes definir el número de réplicas al crear el servicio:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service create --name api --replicas 4 myimage</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swarm se encarga de distribuir las réplicas entre los nodos disponibles, reiniciar instancias fallidas y mantener el estado deseado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_balanceo_de_carga_interno">Balanceo de carga interno</h4>
<div class="paragraph">
<p>Swarm implementa un balanceador de carga interno que distribuye automáticamente las peticiones entrantes entre todas las réplicas de un servicio.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando publicas un puerto (<code>-p 80:80</code>), Swarm expone el servicio en todos los nodos del clúster, no solo en el nodo donde corre el contenedor.</p>
</li>
<li>
<p>El tráfico recibido en ese puerto se enruta a cualquiera de las réplicas disponibles, usando la red overlay <code>ingress</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service create --name web --replicas 3 -p 8080:80 nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes acceder a <code><a href="http://&lt;ip_de_cualquier_nodo&gt;:8080" class="bare">http://&lt;ip_de_cualquier_nodo&gt;:8080</a></code> y Swarm balanceará las peticiones entre las réplicas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_balanceo_de_carga_externo">Balanceo de carga externo</h4>
<div class="paragraph">
<p>Para entornos de producción, es habitual usar un balanceador de carga externo (como HAProxy, NGINX o un balanceador de la nube) delante del clúster Swarm para distribuir el tráfico entrante y gestionar SSL, reglas avanzadas, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_actualización_dinámica_del_escalado">Actualización dinámica del escalado</h4>
<div class="paragraph">
<p>Puedes aumentar o reducir el número de réplicas en cualquier momento, sin interrumpir el servicio:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service scale api=10
docker service scale api=2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swarm creará o eliminará tareas automáticamente para alcanzar el nuevo estado deseado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ver_el_estado_de_las_réplicas">Ver el estado de las réplicas</h4>
<div class="listingblock">
<div class="title">Para comprobar cómo están distribuidas las tareas y su estado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service ps web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_16">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Escala los servicios críticos con al menos 2-3 réplicas para alta disponibilidad.</p>
</li>
<li>
<p>Supervisa el uso de recursos y ajusta el escalado según la demanda.</p>
</li>
<li>
<p>Usa políticas de actualización para evitar downtime durante cambios de versión.</p>
</li>
<li>
<p>Considera el uso de balanceadores externos para escenarios avanzados.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_actualizaciones_y_rollbacks_de_servicios">Actualizaciones y rollbacks de servicios</h3>
<div class="paragraph">
<p>Docker Swarm permite actualizar servicios de manera controlada y segura, minimizando el downtime y facilitando la reversión (rollback) en caso de errores. Estas capacidades son esenciales para mantener la disponibilidad y la calidad en entornos de producción.</p>
</div>
<div class="sect3">
<h4 id="_actualizaciones_rolling_updates">Actualizaciones (Rolling Updates)</h4>
<div class="paragraph">
<p>Una actualización de servicio en Swarm reemplaza gradualmente las tareas (contenedores) antiguas por nuevas, siguiendo una política definida. Esto permite actualizar la imagen, variables de entorno, comandos, etc., sin interrumpir el servicio.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo: actualizar la imagen de un servicio</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service update --image nginx:alpine web</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por defecto, Swarm realiza la actualización de forma escalonada (rolling update), reemplazando las tareas una a una.</p>
</div>
<div class="ulist">
<div class="title">Parámetros útiles para controlar la actualización:</div>
<ul>
<li>
<p><code>--update-parallelism</code>: Número de tareas a actualizar simultáneamente.</p>
</li>
<li>
<p><code>--update-delay</code>: Tiempo de espera entre actualizaciones de tareas.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo: actualizar dos tareas a la vez, esperando 10 segundos entre cada lote</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service update --image nginx:alpine --update-parallelism 2 --update-delay 10s web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rollback_reversión_de_servicios">Rollback (reversión de servicios)</h4>
<div class="paragraph">
<p>Si una actualización falla o se detecta un problema, Swarm permite revertir el servicio a la versión anterior automáticamente o bajo demanda.</p>
</div>
<div class="listingblock">
<div class="title">Para forzar un rollback manual:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service rollback web</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swarm restaurará la configuración y la imagen previa del servicio.</p>
</div>
</div>
<div class="sect3">
<h4 id="_políticas_de_actualización_y_rollback">Políticas de actualización y rollback</h4>
<div class="paragraph">
<p>Puedes definir políticas para controlar el comportamiento ante fallos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>--update-failure-action</code>: Qué hacer si falla una actualización (<code>pause</code>, <code>continue</code>, <code>rollback</code>).</p>
</li>
<li>
<p><code>--rollback-parallelism</code> y <code>--rollback-delay</code>: Controlan la velocidad del rollback.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo: pausar la actualización si falla alguna tarea</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service update --update-failure-action pause web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ver_el_historial_y_estado_de_actualizaciones">Ver el historial y estado de actualizaciones</h4>
<div class="listingblock">
<div class="title">Para ver el historial de actualizaciones y el estado actual del servicio:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service inspect --pretty web
docker service ps web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_17">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Prueba las actualizaciones en entornos de staging antes de aplicarlas en producción.</p>
</li>
<li>
<p>Usa rolling updates para minimizar el downtime.</p>
</li>
<li>
<p>Supervisa el estado de las tareas durante la actualización.</p>
</li>
<li>
<p>Define políticas de rollback automáticas para servicios críticos.</p>
</li>
<li>
<p>Documenta los cambios y versiones desplegadas.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_redes_y_volúmenes_en_swarm">Redes y volúmenes en Swarm</h3>
<div class="paragraph">
<p>Docker Swarm extiende el modelo de redes y volúmenes de Docker para soportar aplicaciones distribuidas en múltiples nodos, permitiendo la comunicación eficiente y la persistencia de datos en entornos de clúster.</p>
</div>
<div class="sect3">
<h4 id="_redes_en_swarm">Redes en Swarm</h4>
<div class="paragraph">
<p>Swarm utiliza principalmente redes de tipo <code>overlay</code>, que permiten la comunicación entre servicios desplegados en diferentes nodos del clúster.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Red overlay</strong>: Red virtual que conecta contenedores en distintos hosts del clúster Swarm. Es ideal para microservicios y aplicaciones distribuidas.</p>
</li>
<li>
<p><strong>Red ingress</strong>: Red overlay especial creada automáticamente por Swarm para el balanceo de carga de servicios publicados con puertos.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Crear una red overlay personalizada:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create --driver overlay mi_red_overlay</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Asignar la red a un servicio:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service create --name web --network mi_red_overlay -p 8080:80 nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_volúmenes_en_swarm">Volúmenes en Swarm</h4>
<div class="paragraph">
<div class="title">Los servicios conectados a la misma red overlay pueden comunicarse usando el nombre del servicio como hostname, gracias al DNS interno de Swarm.</div>
<p>Swarm permite definir volúmenes para persistir datos de servicios, pero hay consideraciones importantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los volúmenes locales (<code>local</code>) solo son accesibles desde el nodo donde se crean. Si una tarea se mueve a otro nodo, no tendrá acceso a los datos.</p>
</li>
<li>
<p>Para persistencia real y alta disponibilidad, utiliza drivers de volúmenes compatibles con almacenamiento compartido (NFS, GlusterFS, Amazon EFS, etc.).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Definir un volumen en un servicio Swarm:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: "3.9"
services:
  db:
    image: postgres:15
    volumes:
      - datos_pg:/var/lib/postgresql/data
    deploy:
      placement:
        constraints: [node.role == manager]

volumes:
  datos_pg:</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear un volumen con driver externo (ejemplo NFS):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker volume create --driver local \
  --opt type=nfs \
  --opt o=addr=192.168.1.100,rw \
  --opt device=:/ruta/nfs/datos \
  datos_nfs</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Asignar el volumen a un servicio:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service create --name app --mount type=volume,source=datos_nfs,target=/app/datos myimage</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_18">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa redes overlay para conectar servicios distribuidos en el clúster.</p>
</li>
<li>
<p>Define redes separadas para aislar servicios según su función (frontend, backend, etc.).</p>
</li>
<li>
<p>Para datos críticos, utiliza volúmenes con almacenamiento compartido y redundante.</p>
</li>
<li>
<p>Documenta la topología de red y la estrategia de persistencia de tu aplicación Swarm.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_docker_en_producción">Docker en Producción</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En este abordan las mejores prácticas, consideraciones y herramientas clave para ejecutar Docker en entornos de producción. El objetivo es garantizar la seguridad, el rendimiento, la escalabilidad y la observabilidad de las aplicaciones desplegadas con contenedores.</p>
</div>
<div class="sect2">
<h3 id="_consideraciones_de_seguridad">Consideraciones de seguridad</h3>
<div class="paragraph">
<p>La seguridad es un aspecto crítico al ejecutar Docker en producción. Un enfoque proactivo ayuda a proteger tus aplicaciones, datos y la infraestructura subyacente. A continuación se presentan recomendaciones didácticas y estructuradas para fortalecer la seguridad en entornos Docker.</p>
</div>
<div class="sect3">
<h4 id="_principio_de_mínimo_privilegio">Principio de mínimo privilegio</h4>
<div class="ulist">
<ul>
<li>
<p>Ejecuta los contenedores con usuarios no root siempre que sea posible. Usa la instrucción <code>USER</code> en el Dockerfile.</p>
</li>
<li>
<p>Evita el uso de la opción <code>--privileged</code> salvo que sea estrictamente necesario.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-lang="dockerfile">USER appuser</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_actualización_y_escaneo_de_imágenes">Actualización y escaneo de imágenes</h4>
<div class="ulist">
<ul>
<li>
<p>Mantén las imágenes y dependencias actualizadas para evitar vulnerabilidades conocidas.</p>
</li>
<li>
<p>Utiliza herramientas de escaneo como <code>docker scan</code>, Trivy o Clair para analizar imágenes en busca de vulnerabilidades.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de escaneo de imagen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker scan miimagen:latest
trivy image miimagen:latest</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reducción_de_superficie_de_ataque">Reducción de superficie de ataque</h4>
<div class="ulist">
<ul>
<li>
<p>Usa imágenes base minimalistas (<code>alpine</code>, <code>slim</code>) y elimina herramientas innecesarias.</p>
</li>
<li>
<p>Elimina paquetes y archivos temporales tras la instalación de dependencias.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_segura_de_secretos">Gestión segura de secretos</h4>
<div class="ulist">
<ul>
<li>
<p>No almacenes contraseñas, claves o secretos en imágenes ni variables de entorno.</p>
</li>
<li>
<p>Utiliza Docker Secrets, gestores externos (Vault, AWS Secrets Manager) o archivos montados en tiempo de ejecución.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de Docker Secrets:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">echo "mi_secreto" | docker secret create db_password -</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_aislamiento_de_redes_y_servicios">Aislamiento de redes y servicios</h4>
<div class="ulist">
<ul>
<li>
<p>Separa servicios críticos en redes personalizadas y limita la exposición de puertos.</p>
</li>
<li>
<p>Usa firewalls y reglas de red para restringir el acceso entre servicios y desde el exterior.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de creación de una red personalizada:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker network create backend
docker run -d --name db --network backend postgres</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_control_de_acceso_y_auditoría">Control de acceso y auditoría</h4>
<div class="ulist">
<ul>
<li>
<p>Configura roles y permisos en el host y en los registros de imágenes (Docker Hub, registries privados).</p>
</li>
<li>
<p>Habilita la auditoría de eventos y accesos al daemon Docker.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_protección_del_daemon_docker">Protección del daemon Docker</h4>
<div class="ulist">
<ul>
<li>
<p>No expongas el socket Docker (<code>/var/run/docker.sock</code>) a contenedores o usuarios no autorizados.</p>
</li>
<li>
<p>Si necesitas acceso remoto, usa TLS para cifrar la comunicación.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actualización_y_parches_del_host">Actualización y parches del host</h4>
<div class="ulist">
<ul>
<li>
<p>Mantén el sistema operativo y Docker Engine actualizados con los últimos parches de seguridad.</p>
</li>
<li>
<p>Usa mecanismos de seguridad del sistema operativo como AppArmor, SELinux o seccomp.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_adicionales_2">Buenas prácticas adicionales</h4>
<div class="ulist">
<ul>
<li>
<p>Elimina imágenes, contenedores y volúmenes no utilizados para reducir riesgos.</p>
</li>
<li>
<p>Usa etiquetas y versionado para identificar imágenes seguras y aprobadas.</p>
</li>
<li>
<p>Documenta y revisa periódicamente la política de seguridad de tus despliegues Docker.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rendimiento_y_escalabilidad">Rendimiento y escalabilidad</h3>
<div class="paragraph">
<p>Garantizar el rendimiento y la escalabilidad de aplicaciones en Docker es esencial para entornos de producción. A continuación se presentan estrategias, recomendaciones y ejemplos prácticos para optimizar el uso de recursos y escalar servicios de manera eficiente.</p>
</div>
<div class="sect3">
<h4 id="_optimización_de_imágenes">Optimización de imágenes</h4>
<div class="ulist">
<ul>
<li>
<p>Usa imágenes base ligeras (<code>alpine</code>, <code>slim</code>) para reducir el tamaño y acelerar despliegues.</p>
</li>
<li>
<p>Minimiza el número de capas en el Dockerfile agrupando comandos RUN.</p>
</li>
<li>
<p>Elimina archivos temporales y dependencias de desarrollo tras la instalación.</p>
</li>
<li>
<p>Utiliza multi-stage builds para separar la construcción y la ejecución.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_asignación_y_limitación_de_recursos">Asignación y limitación de recursos</h4>
<div class="ulist">
<ul>
<li>
<p>Limita el uso de CPU y memoria de los contenedores para evitar que un servicio consuma todos los recursos del host.</p>
</li>
<li>
<p>Usa las opciones <code>--cpus</code>, <code>--memory</code> y <code>--memory-swap</code> en <code>docker run</code> o en la sección <code>deploy.resources</code> de Docker Compose/Swarm.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run -d --name app --cpus="1.5" --memory="512m" myimage</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">En Compose (Swarm):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">deploy:
  resources:
    limits:
      cpus: '1.0'
      memory: 512M
    reservations:
      cpus: '0.5'
      memory: 256M</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_escalabilidad_horizontal">Escalabilidad horizontal</h4>
<div class="ulist">
<ul>
<li>
<p>Escala servicios ejecutando múltiples réplicas de un mismo contenedor.</p>
</li>
<li>
<p>Usa orquestadores como Docker Swarm o Kubernetes para gestionar el escalado automático y el balanceo de carga.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo en Swarm:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service scale web=5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_almacenamiento_eficiente">Almacenamiento eficiente</h4>
<div class="ulist">
<ul>
<li>
<p>Usa volúmenes gestionados por Docker o soluciones externas para datos persistentes.</p>
</li>
<li>
<p>Monitoriza el uso de disco y realiza limpieza periódica de imágenes y volúmenes no utilizados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_redes_y_comunicación">Redes y comunicación</h4>
<div class="ulist">
<ul>
<li>
<p>Usa redes personalizadas para aislar servicios y optimizar el tráfico interno.</p>
</li>
<li>
<p>Minimiza la latencia conectando servicios relacionados en la misma red Docker.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_monitorización_y_ajuste_de_recursos">Monitorización y ajuste de recursos</h4>
<div class="ulist">
<ul>
<li>
<p>Utiliza <code>docker stats</code> para monitorizar el consumo de recursos en tiempo real.</p>
</li>
<li>
<p>Integra herramientas como Prometheus y Grafana para métricas avanzadas y alertas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_19">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Realiza pruebas de carga y estrés para identificar cuellos de botella.</p>
</li>
<li>
<p>Ajusta los límites de recursos según el comportamiento real de la aplicación.</p>
</li>
<li>
<p>Documenta la configuración de recursos y escalabilidad para cada servicio.</p>
</li>
<li>
<p>Automatiza el escalado y la recuperación ante fallos con orquestadores.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_monitorización_y_logging_2">Monitorización y logging</h3>
<div class="paragraph">
<p>La monitorización y el registro centralizado de logs son fundamentales para garantizar la observabilidad, el diagnóstico y la operación eficiente de aplicaciones en producción con Docker. A continuación se presentan estrategias, herramientas y buenas prácticas para monitorizar y gestionar logs en entornos de contenedores.</p>
</div>
<div class="sect3">
<h4 id="_monitorización_de_contenedores">Monitorización de contenedores</h4>
<div class="ulist">
<ul>
<li>
<p>Utiliza <code>docker stats</code> para ver el uso de CPU, memoria, red y disco en tiempo real.</p>
</li>
<li>
<p>Integra herramientas como <strong>Prometheus</strong> y <strong>Grafana</strong> para recolectar y visualizar métricas avanzadas de contenedores, hosts y servicios.</p>
</li>
<li>
<p>Considera soluciones como <strong>cAdvisor</strong> para monitorizar recursos a nivel de contenedor.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Ejemplo de integración con Prometheus:</div>
<ul>
<li>
<p>Despliega el exporter de Docker para Prometheus.</p>
</li>
<li>
<p>Configura Prometheus para recolectar métricas del endpoint del exporter.</p>
</li>
<li>
<p>Visualiza las métricas en Grafana mediante dashboards personalizados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_logging_de_contenedores">Logging de contenedores</h4>
<div class="ulist">
<ul>
<li>
<p>Por defecto, Docker almacena los logs de los contenedores en archivos JSON en el host.
.Puedes ver los logs con:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>docker logs &lt;nombre_o_id_contenedor&gt;</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para aplicaciones multicontenedor, usa:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose logs</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_centralización_de_logs">Centralización de logs</h4>
<div class="ulist">
<ul>
<li>
<p>Redirige los logs a sistemas centralizados como <strong>ELK Stack</strong> (Elasticsearch, Logstash, Kibana), <strong>Loki</strong>, <strong>Fluentd</strong> o servicios cloud.</p>
</li>
<li>
<p>Configura el driver de logging de Docker (<code>--log-driver</code>) para enviar los logs directamente a la solución elegida.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo para usar Fluentd:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run --log-driver=fluentd myimage</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_de_monitorización_y_logging">Buenas prácticas de monitorización y logging</h4>
<div class="ulist">
<ul>
<li>
<p>Define alertas para eventos críticos (caída de servicios, uso excesivo de recursos, errores de aplicación).</p>
</li>
<li>
<p>Mantén políticas de retención y rotación de logs para evitar llenar el disco.</p>
</li>
<li>
<p>Documenta los procedimientos de acceso y análisis de logs para el equipo.</p>
</li>
<li>
<p>Integra la monitorización y logging en tus pipelines de CI/CD para detectar problemas tempranamente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_stack_de_monitorización_y_logging">Ejemplo de stack de monitorización y logging</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Prometheus + Grafana</strong>: Métricas y visualización.</p>
</li>
<li>
<p><strong>ELK Stack</strong>: Centralización, búsqueda y visualización de logs.</p>
</li>
<li>
<p><strong>Loki + Grafana</strong>: Logs ligeros y escalables para entornos de contenedores.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estrategias_de_despliegue">Estrategias de despliegue</h3>
<div class="paragraph">
<p>El despliegue de aplicaciones en contenedores Docker en producción requiere estrategias que garanticen disponibilidad, mínima interrupción y facilidad de recuperación ante fallos. A continuación se presentan las principales estrategias de despliegue y recomendaciones para entornos reales.</p>
</div>
<div class="sect3">
<h4 id="_despliegue_tradicional_stop_start">Despliegue tradicional (stop &amp; start)</h4>
<div class="ulist">
<ul>
<li>
<p>Detener la versión antigua y arrancar la nueva.</p>
</li>
<li>
<p>Sencillo pero implica downtime y no es recomendable para servicios críticos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_rolling_update_actualización_escalonada">Rolling Update (actualización escalonada)</h4>
<div class="ulist">
<ul>
<li>
<p>Actualiza gradualmente las instancias del servicio, reemplazando contenedores antiguos por nuevos sin detener todo el sistema.</p>
</li>
<li>
<p>Soportado nativamente por Docker Swarm y Kubernetes.</p>
</li>
<li>
<p>Permite controlar el número de instancias actualizadas simultáneamente y el tiempo de espera entre actualizaciones.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo en Swarm:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service update --image miapp:v2 --update-parallelism 2 --update-delay 10s web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bluegreen_deployment">Blue/Green Deployment</h4>
<div class="ulist">
<ul>
<li>
<p>Mantiene dos entornos idénticos: uno activo (blue) y otro inactivo (green).</p>
</li>
<li>
<p>Se despliega la nueva versión en el entorno inactivo y, tras las pruebas, se redirige el tráfico al nuevo entorno.</p>
</li>
<li>
<p>Permite rollback inmediato si hay problemas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_canary_deployment">Canary Deployment</h4>
<div class="ulist">
<ul>
<li>
<p>Despliega la nueva versión solo a un pequeño porcentaje de usuarios o tráfico.</p>
</li>
<li>
<p>Permite validar la nueva versión en producción antes de un despliegue completo.</p>
</li>
<li>
<p>Requiere balanceadores de carga o herramientas de orquestación avanzadas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_zero_downtime_deployment">Zero Downtime Deployment</h4>
<div class="ulist">
<ul>
<li>
<p>Estrategias y herramientas que aseguran que no haya interrupción del servicio durante el despliegue.</p>
</li>
<li>
<p>Utiliza rolling updates, balanceadores de carga y readiness checks para garantizar la disponibilidad.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_automatización_del_despliegue">Automatización del despliegue</h4>
<div class="ulist">
<ul>
<li>
<p>Integra Docker en pipelines de CI/CD para automatizar builds, tests y despliegues.</p>
</li>
<li>
<p>Usa herramientas como Jenkins, GitHub Actions, GitLab CI, ArgoCD, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_20">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Versiona y etiqueta todas las imágenes desplegadas.</p>
</li>
<li>
<p>Realiza pruebas en entornos de staging antes de producción.</p>
</li>
<li>
<p>Supervisa el despliegue y define alertas ante fallos.</p>
</li>
<li>
<p>Documenta el proceso y los comandos de despliegue.</p>
</li>
<li>
<p>Prepara procedimientos de rollback claros y probados.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_docker_swarm_orquestación_básica">Docker Swarm (orquestación básica)</h3>
<div class="paragraph">
<p>Docker Swarm es la solución de orquestación nativa de Docker que permite gestionar clústeres de contenedores de forma sencilla y eficiente. Swarm facilita el despliegue, escalado, balanceo de carga y alta disponibilidad de aplicaciones distribuidas en múltiples hosts.</p>
</div>
<div class="sect3">
<h4 id="_características_principales">Características principales</h4>
<div class="ulist">
<ul>
<li>
<p>Orquestación integrada en Docker Engine.</p>
</li>
<li>
<p>Gestión de clústeres con nodos manager y worker.</p>
</li>
<li>
<p>Despliegue de servicios replicados y globales.</p>
</li>
<li>
<p>Balanceo de carga interno y descubrimiento de servicios.</p>
</li>
<li>
<p>Rolling updates y rollbacks automáticos.</p>
</li>
<li>
<p>Redes overlay para comunicación entre servicios en diferentes nodos.</p>
</li>
<li>
<p>Gestión de secretos y configuración segura.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_flujo_básico_de_uso">Flujo básico de uso</h4>
<div class="listingblock">
<div class="title"><strong>Inicializar el clúster Swarm</strong> en el nodo manager:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker swarm init</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Unir nodos workers</strong> al clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker swarm join --token &lt;token&gt; &lt;ip_manager&gt;:2377</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Desplegar un servicio replicado</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service create --name web --replicas 3 -p 80:80 nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Escalar servicios</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service scale web=5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Actualizar servicios con rolling update</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service update --image nginx:alpine web</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Ver el estado del clúster y servicios</strong>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker node ls
docker service ls
docker service ps web</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_21">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa al menos 3 nodos manager para alta disponibilidad.</p>
</li>
<li>
<p>Mantén los tokens de join seguros.</p>
</li>
<li>
<p>Utiliza redes overlay para aislar servicios.</p>
</li>
<li>
<p>Supervisa el estado de los nodos y servicios regularmente.</p>
</li>
<li>
<p>Documenta la topología y configuración del clúster.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_integración_continua_y_entrega_continua_cicd">Integración Continua y Entrega Continua (CI/CD)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La Integración Continua (CI) y la Entrega Continua (CD) son prácticas clave en el desarrollo moderno de software, permitiendo automatizar la construcción, prueba y despliegue de aplicaciones. Docker facilita la implementación de pipelines CI/CD eficientes, reproducibles y portables.</p>
</div>
<div class="sect2">
<h3 id="_docker_en_pipelines_de_cicd">Docker en pipelines de CI/CD</h3>
<div class="paragraph">
<p>Docker es una herramienta fundamental en los pipelines de Integración Continua (CI) y Entrega Continua (CD), ya que permite construir, probar y desplegar aplicaciones en entornos consistentes y reproducibles.</p>
</div>
<div class="sect3">
<h4 id="_ventajas_de_usar_docker_en_cicd">Ventajas de usar Docker en CI/CD</h4>
<div class="ulist">
<ul>
<li>
<p>Elimina el clásico "en mi máquina funciona" al garantizar entornos idénticos en desarrollo, pruebas y producción.</p>
</li>
<li>
<p>Permite empaquetar la aplicación y sus dependencias en una imagen inmutable.</p>
</li>
<li>
<p>Facilita la ejecución de pruebas automatizadas en contenedores aislados.</p>
</li>
<li>
<p>Acelera la entrega de nuevas versiones mediante despliegues automáticos y controlados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_flujo_típico_de_un_pipeline_cicd_con_docker">Flujo típico de un pipeline CI/CD con Docker</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Build</strong>: Construcción de la imagen Docker a partir del código fuente y el Dockerfile.</p>
</li>
<li>
<p><strong>Test</strong>: Ejecución de pruebas unitarias, de integración o end-to-end dentro de contenedores.</p>
</li>
<li>
<p><strong>Push</strong>: Publicación de la imagen en un registro (Docker Hub, GitHub Container Registry, etc.).</p>
</li>
<li>
<p><strong>Deploy</strong>: Despliegue automático de la imagen en entornos de staging o producción.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_pipeline_pseudocódigo">Ejemplo básico de pipeline (pseudocódigo)</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Ejemplo simplificado de pasos en un pipeline CI/CD
steps:
  - name: Checkout código
    run: git clone &lt;repo&gt;
  - name: Build imagen
    run: docker build -t usuario/app:latest .
  - name: Test
    run: docker run --rm usuario/app:latest pytest
  - name: Push a registro
    run: docker push usuario/app:latest
  - name: Deploy
    run: kubectl set image deployment/app app=usuario/app:latest</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integración_con_herramientas_populares">Integración con herramientas populares</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Jenkins</strong>: Usa plugins oficiales para construir y publicar imágenes Docker.</p>
</li>
<li>
<p><strong>GitHub Actions</strong>: Permite definir workflows YAML para automatizar builds, tests y despliegues con Docker.</p>
</li>
<li>
<p><strong>GitLab CI</strong>: Incluye runners con soporte nativo para Docker.</p>
</li>
<li>
<p><strong>Azure Pipelines, CircleCI, Travis CI</strong>: Todos soportan pasos con Docker.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_22">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Versiona las imágenes usando tags únicos (por commit, rama o versión).</p>
</li>
<li>
<p>Usa archivos <code>.dockerignore</code> para optimizar el contexto de build.</p>
</li>
<li>
<p>Realiza pruebas en contenedores idénticos a los de producción.</p>
</li>
<li>
<p>Elimina imágenes y contenedores temporales al finalizar los jobs para ahorrar espacio.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_automatización_de_builds_y_tests">Automatización de builds y tests</h3>
<div class="paragraph">
<p>Automatizar la construcción de imágenes y la ejecución de pruebas es una de las principales ventajas de integrar Docker en pipelines de CI/CD. Esto garantiza que cada cambio en el código pase por un proceso reproducible y controlado antes de ser desplegado.</p>
</div>
<div class="sect3">
<h4 id="_build_automatizado_de_imágenes">Build automatizado de imágenes</h4>
<div class="ulist">
<ul>
<li>
<p>Configura tu pipeline para construir la imagen Docker en cada push o pull request.</p>
</li>
<li>
<p>Usa archivos <code>.dockerignore</code> para optimizar el contexto de build y reducir tiempos.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de build en un pipeline:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker build -t usuario/app:${GITHUB_SHA} .</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_de_tests_en_contenedores">Ejecución de tests en contenedores</h4>
<div class="ulist">
<ul>
<li>
<p>Ejecuta pruebas unitarias, de integración o end-to-end dentro de contenedores para asegurar que el entorno es idéntico al de producción.</p>
</li>
<li>
<p>Puedes usar el mismo contenedor que se desplegará o uno específico para testing.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de ejecución de tests:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker run --rm usuario/app:${GITHUB_SHA} pytest</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">O bien, usando docker-compose para levantar servicios dependientes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker-compose -f docker-compose.test.yml up --abort-on-container-exit --exit-code-from app</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_limpieza_automática">Limpieza automática</h4>
<div class="listingblock">
<div class="title">Elimina imágenes y contenedores temporales al finalizar los jobs para ahorrar espacio y evitar acumulación de recursos.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker system prune -af</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_23">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Versiona las imágenes con el hash del commit o número de build.</p>
</li>
<li>
<p>Separa los pasos de build y test para facilitar la depuración.</p>
</li>
<li>
<p>Falla rápido: detén el pipeline ante el primer error.</p>
</li>
<li>
<p>Integra los resultados de los tests en el sistema de reportes del pipeline.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_workflow_en_github_actions">Ejemplo de workflow en GitHub Actions</h4>
<div class="listingblock">
<div class="title">Un ejemplo de workflow en GitHub Actions para construir y probar una imagen Docker:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">name: CI Docker Build &amp; Test

on: [push, pull_request]

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build Docker image
        run: docker build -t usuario/app:${{ github.sha }} .
      - name: Run tests
        run: docker run --rm usuario/app:${{ github.sha }} pytest
      - name: Clean up
        run: docker system prune -af</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_despliegue_automático_de_contenedores">Despliegue automático de contenedores</h3>
<div class="paragraph">
<p>El despliegue automático de contenedores es una práctica esencial en pipelines de CI/CD modernos. Permite que, tras la construcción y prueba de una imagen Docker, esta se despliegue automáticamente en entornos de staging o producción, reduciendo errores manuales y acelerando la entrega de software.</p>
</div>
<div class="sect3">
<h4 id="_flujo_típico_de_despliegue_automático">Flujo típico de despliegue automático</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Build y push de la imagen</strong>: El pipeline construye la imagen y la publica en un registro (Docker Hub, GitHub Container Registry, etc.).</p>
</li>
<li>
<p><strong>Despliegue automático</strong>: Un paso del pipeline o un sistema de automatización detecta la nueva imagen y actualiza el entorno de destino.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_despliegue_automático_con_docker_compose">Ejemplo de despliegue automático con Docker Compose</h4>
<div class="listingblock">
<div class="title">Puedes actualizar servicios en un servidor remoto usando SSH y Docker Compose:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">- name: Deploy en servidor remoto
  run: |
    ssh usuario@servidor "
      cd /ruta/app &amp;&amp;
      docker-compose pull &amp;&amp;
      docker-compose up -d
    "</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_despliegue_automático_en_swarm">Ejemplo de despliegue automático en Swarm</h4>
<div class="listingblock">
<div class="title">Actualiza un servicio en Swarm con la nueva imagen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">docker service update --image usuario/app:latest mi_servicio</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integración_con_pipelines_cicd">Integración con pipelines CI/CD</h4>
<div class="ulist">
<ul>
<li>
<p>Usa herramientas como GitHub Actions, GitLab CI, Jenkins, etc., para automatizar el despliegue tras el push de la imagen.</p>
</li>
<li>
<p>Puedes usar acciones específicas o scripts personalizados para conectar el pipeline con tu infraestructura.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_24">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Versiona las imágenes y usa tags únicos para cada despliegue.</p>
</li>
<li>
<p>Realiza despliegues primero en entornos de staging antes de producción.</p>
</li>
<li>
<p>Automatiza pruebas post-despliegue para validar el estado de la aplicación.</p>
</li>
<li>
<p>Documenta y revisa los procesos de despliegue automático.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_integración_con_herramientas_como_jenkins_github_actions_etc">Integración con herramientas como Jenkins, GitHub Actions, etc.</h3>
<div class="paragraph">
<p>La integración de Docker en herramientas de CI/CD como Jenkins, GitHub Actions, GitLab CI, Azure Pipelines y otras, permite automatizar todo el ciclo de vida de las aplicaciones: construcción, pruebas, publicación y despliegue de imágenes.</p>
</div>
<div class="sect3">
<h4 id="_jenkins">Jenkins</h4>
<div class="ulist">
<ul>
<li>
<p>Usa el plugin oficial de Docker para construir, etiquetar y publicar imágenes desde pipelines declarativos (Jenkinsfile).</p>
</li>
<li>
<p>Permite ejecutar pasos de build y test en contenedores aislados usando agentes Docker.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de etapa en Jenkinsfile:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">pipeline {
  agent any
  stages {
    stage('Build') {
      steps {
        script {
          docker.build("usuario/app:${env.BUILD_NUMBER}")
        }
      }
    }
    stage('Test') {
      steps {
        sh 'docker run --rm usuario/app:${BUILD_NUMBER} pytest'
      }
    }
    stage('Push') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'dockerhub', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
          sh 'echo $PASS | docker login -u $USER --password-stdin'
          sh 'docker push usuario/app:${BUILD_NUMBER}'
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_github_actions">GitHub Actions</h4>
<div class="ulist">
<ul>
<li>
<p>Permite definir workflows YAML para construir, probar y desplegar imágenes Docker en cada push o pull request.</p>
</li>
<li>
<p>Incluye acciones oficiales para login, build y push a Docker Hub o GitHub Container Registry.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de workflow:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">name: CI/CD Docker

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build image
        run: docker build -t usuario/app:${{ github.sha }} .
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASS }}
      - name: Push image
        run: docker push usuario/app:${{ github.sha }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gitlab_ci">GitLab CI</h4>
<div class="ulist">
<ul>
<li>
<p>Incluye runners con soporte nativo para Docker.</p>
</li>
<li>
<p>Permite definir pipelines en <code>.gitlab-ci.yml</code> para build, test y deploy de imágenes.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de job:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">build:
  stage: build
  script:
    - docker build -t registry.gitlab.com/usuario/app:$CI_COMMIT_SHA .
    - docker push registry.gitlab.com/usuario/app:$CI_COMMIT_SHA</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_otras_herramientas">Otras herramientas</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Azure Pipelines, CircleCI, Travis CI</strong>: Todos soportan pasos con Docker para build, test y despliegue.</p>
</li>
<li>
<p>Puedes usar scripts personalizados o extensiones oficiales según la plataforma.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_25">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa variables y secretos seguros para credenciales de registro.</p>
</li>
<li>
<p>Versiona las imágenes con el hash del commit o número de build.</p>
</li>
<li>
<p>Automatiza pruebas y despliegues para cada cambio relevante.</p>
</li>
<li>
<p>Limpia recursos temporales al finalizar los jobs.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recursos_adicionales_2">Recursos Adicionales</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentación_oficial">Documentación oficial</h3>
<div class="ulist">
<ul>
<li>
<p>[Documentación oficial de Docker](<a href="https://docs.docker.com/" class="bare">https://docs.docker.com/</a>)</p>
</li>
<li>
<p>[Docker Compose](<a href="https://docs.docker.com/compose/" class="bare">https://docs.docker.com/compose/</a>)</p>
</li>
<li>
<p>[Docker Swarm](<a href="https://docs.docker.com/engine/swarm/" class="bare">https://docs.docker.com/engine/swarm/</a>)</p>
</li>
<li>
<p>[Dockerfile reference](<a href="https://docs.docker.com/engine/reference/builder/" class="bare">https://docs.docker.com/engine/reference/builder/</a>)</p>
</li>
<li>
<p>[Docker Hub](<a href="https://hub.docker.com/" class="bare">https://hub.docker.com/</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_comunidad_y_soporte">Comunidad y soporte</h3>
<div class="ulist">
<ul>
<li>
<p>[Foros de Docker](<a href="https://forums.docker.com/" class="bare">https://forums.docker.com/</a>)</p>
</li>
<li>
<p>[Stack Overflow: docker](<a href="https://stackoverflow.com/questions/tagged/docker" class="bare">https://stackoverflow.com/questions/tagged/docker</a>)</p>
</li>
<li>
<p>[GitHub de Docker](<a href="https://github.com/docker" class="bare">https://github.com/docker</a>)</p>
</li>
<li>
<p>[Docker Community Slack](<a href="https://www.docker.com/slack" class="bare">https://www.docker.com/slack</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_herramientas_complementarias">Herramientas complementarias</h3>
<div class="ulist">
<ul>
<li>
<p>[Portainer](<a href="https://www.portainer.io/" class="bare">https://www.portainer.io/</a>): Interfaz gráfica para gestión de contenedores y clústeres Docker.</p>
</li>
<li>
<p>[Dive](<a href="https://github.com/wagoodman/dive" class="bare">https://github.com/wagoodman/dive</a>): Analizador de capas de imágenes Docker.</p>
</li>
<li>
<p>[Trivy](<a href="https://github.com/aquasecurity/trivy" class="bare">https://github.com/aquasecurity/trivy</a>): Escáner de vulnerabilidades para imágenes.</p>
</li>
<li>
<p>[cAdvisor](<a href="https://github.com/google/cadvisor" class="bare">https://github.com/google/cadvisor</a>): Monitorización de recursos de contenedores.</p>
</li>
<li>
<p>[ELK Stack](<a href="https://www.elastic.co/what-is/elk-stack" class="bare">https://www.elastic.co/what-is/elk-stack</a>): Centralización y análisis de logs.</p>
</li>
<li>
<p>[Prometheus &amp; Grafana](<a href="https://prometheus.io/" class="bare">https://prometheus.io/</a>): Monitorización y visualización de métricas.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_tendencias_y_futuro_de_docker">Tendencias y futuro de Docker</h3>
<div class="ulist">
<ul>
<li>
<p>Integración con Kubernetes y otros orquestadores.</p>
</li>
<li>
<p>Contenedores rootless y mayor enfoque en seguridad.</p>
</li>
<li>
<p>Imágenes aún más ligeras y optimizadas.</p>
</li>
<li>
<p>Automatización avanzada en CI/CD y GitOps.</p>
</li>
<li>
<p>Expansión de Docker Desktop y herramientas para desarrolladores.</p>
</li>
<li>
<p>Mayor adopción de arquitecturas serverless y microservicios basados en contenedores.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-06-19 09:31:05 +0200
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>